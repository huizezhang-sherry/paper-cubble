---
documentclass: jss
classoption: shortnames
author:
  - name: H. Sherry Zhang
    affiliation: Monash University
    address: 21 Chancellors Walk, Clayton VIC 3800 Australia
    email: \email{huize.zhang@monash.edu}
  - name: Dianne Cook
    affiliation: Monash University
    address: 21 Chancellors Walk, Clayton VIC 3800 Australia
    email: dicook@monash.edu
  - name: Ursula Laa
    affiliation: 'University of  Natural `\\`{=latex} Resources and Life Sciences \AND'
    address: Gregor-Mendel-Straße 33, 1180 Wien, Austria
    email:  ursula.laa@boku.ac.at
  - name: Nicolas Langrené
    affiliation: 'BNU-HKBU `\\`{=latex} United International College'
    address: 2000 Jintong Road, Tangjiawan, Zhuhai, Guangdong Province, China
    email: nicolaslangrene@uic.edu.cn
  - name: Patricia Menéndez
    affiliation: Monash University
    address: 21 Chancellors Walk, Clayton VIC 3800 Australia
    email:  patricia.menendez@monash.edu
title:
  formatted: "\\pkg{cubble}: An \\proglang{R} Package for Organizing and Wrangling Multivariate Spatio-temporal Data"
  # If you use tex in the formatted title, alsoge supply version without
  plain:     "cubble: An R Package for Organizing and Wrangling Multivariate Spatio-temporal Data"
  # For running headers, if needed
  # short:     "\\pkg{foo}: A Capitalized Title"
abstract: >
     Multivariate spatio-temporal data refers to multiple measurements taken across space and time. For many analyses, spatial and time components can be separately studied: for example, to explore the temporal trend of one variable for a single spatial location, or to model the spatial distribution of one variable at a given time. However for some studies, it is important to analyze different aspects of the spatio-temporal data simultaneously, like for instance, temporal trends of multiple variables across locations. In order to facilitate the study of different portions or combinations of spatio-temporal data, we introduce a new class, \code{cubble}, with a suite of functions enabling easy slicing and dicing on different spatio-temporal components.  The proposed \code{cubble} class ensures that all the components of the data are easy to access and manipulate while providing flexibility for data analysis. In addition, the \pkg{cubble} package facilitates visual and numerical explorations of the data while easing data wrangling and modelling. The \code{cubble} class and the tools implemented in the package are illustrated with different examples of Australian climate data.
keywords:
  # at least one keyword must be supplied
  formatted: [spatial, temporal, spatio temporal, "\\proglang{R}", environmental data, exploratory data analysis]
  plain:     [spatial, temporal, spatio temporal, R, environmental data, exploratory data analysis]
preamble: >
  \usepackage{amsmath}
  \usepackage{array}
output: 
  bookdown::pdf_book:
    base_format: rticles::jss_article
bibliography: references.bib
---

```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  fig.path = here::here("figures/")
)

options(prompt = "R> ", continue = "+ ",
        tibble.print_max = 5, tibble.print_min = 5,
        width = 80, styler.cache_root = "styler-perm")
```

```{r echo = FALSE}
library("cubble")
library("dplyr")
library("tidyr")
library("ggplot2")
library("patchwork")
library("tsibble")
library("sf")
library("lubridate")
library("ozmaps")
library("ggthemes")
library("ggrepel")
library("ncdf4")
library("rnaturalearth")
library("colorspace")
library("units")
```

# Introduction

Spatio-temporal data has a spatial component referring to the location of each observation and a temporal component that is recorded at regular or irregular time intervals. It may also include multiple variables measured at each spatial and temporal values. With spatio-temporal data, one can fix the time to explore the spatial features of the data, fix the spatial location/s to explore temporal aspects, or dynamically explore the space and time simultaneously. 

In order to computationally explore the spatial, temporal and spatio-temporal faces of such data, the data needs to be stored and represented under a specific data object that allows the user to query, group and dissect all the data faces.

The Comprehensive \proglang{R} Archive Network (CRAN) task view SpatioTemporal [@ctvspatiotemporal] gathers information about \proglang{R} packages designed for spatio-temporal data and it has a section on *Representing data* that lists existing spatio-temporal data representations used in \proglang{R}. Among them, the \pkg{spacetime} package [@spacetime] implements four S4 classes to handle spatio-temporal data with different spatio-temporal layouts (full grid, sparse grid, irregular, and trajectory). The \pkg{stars} package [@stars] implements an S3 class built from dense arrays.

Still, these two implementations are not necessarily easy to work in analysis for analysts with a tidyverse mindset. In tidyverse, data are in tables and the tidy data concept [@tidydata] prescribes three principles on how data should be organised for easier analysis as 1) one observation a row, 2) one variable a column, and 3) one type of observation a table. The third principle of tidy data is particularly relevant for spatio-temporal data since spatial and temporal data are naturally observed at different units: the location and location at different times. While the tidyverse suite implements data wrangling and visualisation tools operated on a single table, there has not been many tools for handling relational data for spatio-temporal analysis. This motivates a new design to organise spatio-temporal data in a way that would make data wrangling, visualizing and analyzing easier.

This paper presents a new \proglang{R} package, \pkg{cubble}, which implements a new cubble class to organize spatial and temporal variables as two forms of a single data object so that they can be wrangled separately or combined, while being kept synchronized. Among the four spacetime layouts in @spacetime, the \code{cubble} class can handle the full grid layout and the sparse grid layout.  The software is available from the Comprehensive \proglang{R} Archive Network (CRAN) at https://CRAN.R-project.org/package=cubble. 

The rest of the paper is organized as follows: Section \@ref(cubble) presents the main design and functionality of the \pkg{cubble} package. Section \@ref(others) explains how the \pkg{cubble} package deals with more advanced considerations, including data matching and how the package fits with existing static and interactive visualization tools. Moreover we also illustrate how the \pkg{cubble} package deals with spatio-temporal data transformations. Section \@ref(examples) uses primarily Australian weather station data as examples to demonstrate the use of the package. An example of how the \pkg{cubble} package handles Network Common Data Form (NetCDF) data is also provided. Section \@ref(conclude) discuss the paper contributions and future directions.

# The cubble package {#cubble}

## The cubble object {#object}

Spatio-temporal data can encompass data with various spatial and temporal characteristics, requiring different structures for wrangling and analysis. For example, climate weather stations typically store station metadata in one table and the climate time series in another. GPS data tracks unique point locations at different timestamps and is represented as trajectories. Satellite imageries capture snapshots of landscapes at selected time and is commonly structured as raster data. In this paper, we propose the \pkg{cubble} package to organise spatio-temporal data collected at unique fixed locations while allowing for irregularities in the temporal dimension, such as weather station data. 

The cubble class is an S3 class built on tibble that allows the spatio-temporal data to be wrangled in two forms (subclasses):

-   a spatial cubble with class `c("spatial_cubble_df", "cubble_df")`
-   a temporal cubble with class `c("temporal_cubble_df", "cubble_df")`

In a spatial cubble, spatial variables are organised as columns and temporal variables are nested within a specialised `ts` column. The spatial cubble object, \code{cb_nested}, printed below contains weather records of three airport stations from Global Historical Climatology Network Daily (GHCND). The spatial cubble is convenient for wrangling the spatial variables:

```{r}
cb_nested <- climate_mel
```

```{r echo = TRUE}
cb_nested
```

In a temporal cubble, temporal variables are expanded in the long form and spatial variables are stored as a data attribute. The temporal cubble object, \code{cb_long}, contains the same spatio-temporal data as the spatial cubble object, \code{cb_nested}, but in a structure that is easier for temporal analysis: 

```{r}
cb_long <- face_temporal(climate_mel)
```

```{r echo = TRUE}
cb_long
```

### The cubble attributes

```{r class, fig.align="center", out.width = "100%", fig.cap = "Illustration of a cubble object in the long form and nested form, along with the associated attributes."}
#knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.004.png"))
```

A cubble object inherits the attributes from tibble (and its subclasses): `class`, `row.names`, and `names`. Additionally, it has three specialised attributes: `key`, `index`, and `coords`. Readers who are familiar with the `key` and `index` attributes from the `tsibble` package would already understand the two arguments. In cubble, the `key` attribute identifies the row in the spatial cubble (given the internal use of `tidyr::nest()` for nesting), and when combined with the `index` argument, it identifies the row in the temporal cubble. Currently, cubble only supports one variable as the key, and the accepted temporal classes for index includes the base R classes `Date`, `POSIXlt`, `POSIXct`, as well as tsibble's `yearmonth`, `yearweek`, and `yearquarter` classes. The `coords` attribute represents an ordered pair of coordinates. It can be either an unprojected pair of longitude and latitude, or a projected easting and northing value. The `sf` package is used under the hood to calculate the bounding box, displayed in the header of a spatial cubble.

The temporal cubble has a special attribute called `spatial` to store the spatial variables. Shortcut functions are available to extract attributes, for example, \code{spatial()} for extracting spatial variables from the temporal cubble: 

```{r echo = TRUE}
spatial(cb_long)
```

## Creation and coercion {#create}

<!-- In many cases, spatio-temporal data arrive in separate tables for analysis. For example, in climate data, analysts may initially receive station data containing geographic location information, recorded variables and their recording periods. They can then query the temporal variables using the stations of interest to obtain the relevant temporal data. Alternatively, analyses may begin as purely spatial or temporal, and analysts may obtain additional temporal or spatial data to expand the result to spatio-temporal. -->

The function \code{make_cubble()} composes a spatial cubble object from a spatial table (\code{spatial}) and a temporal table (\code{temporal}), along with three attributes introduced in the subsection \@ref(object): \code{key}, \code{index}, and \code{coords}. The following code creates a spatial cubble from its spatial component, \code{stations} and temporal component \code{meteo}:

```{r echo = TRUE}
make_cubble(spatial = stations, temporal = meteo,
            key = id, index = date, coords = c(long, lat))
```

Other foreign spatio-temporal objects in \proglang{R} can be coerced into a \code{cubble} object with the function \code{as_cubble()}. This includes a joined \code{tibble} or \code{data.frame}, a NetCDF object, a \code{stars} object [@stars], and a \code{sftime} object [@sftime]. In the example below, the spatial cubble object is created from \code{climate_flat}, which combines the previous \code{stations} and \code{meteo} into a single tibble object: 

```{r echo = TRUE}
climate_flat |> as_cubble(key = id, index = date, coords = c(long, lat))
```

## Functions and methods

Table \@ref(tab:funs) summarises the functions implemented in the \pkg{cubble} package and Table \@ref(tab:methods) details the methods implemented for each of the three cubble classes. The \code{cubble_df} class handles methods that behave consistently in both spatial and temporal cubble. When the method has distinct behavior, it is implemented separately in \code{spatial_cubble_df} and \code{temporal_cubble_df}.

| Category  | Functions |
|--------|--------------------------------------------------------|
| base R    | `[`, `[[<-`, `names<-` |
| tidyverse | `dplyr_row_slice`, `dplyr_col_modify`, `dplyr_reconstruct`, `select`, `mutate`, `arrange`, `filter`, `group_by`, `ungroup`, `summarise`, `select`, `slice`, `rowwise`, `rename`, `bind_rows`, `bind_cols`, `relocate`, `type_sum`, the slice family (`slice_head`, `slice_tail`, `slice_max`, `slice_min`, `slice_sample`) and the join family (`left_join`, `right_join`, `inner_join`, `full_join`, `anti_join`, `semi_join`) |
| cubble    | `as_cubble`, `cubble`, `make_cubble`, `check_key`, `face_temporal`, `face_spatial`, `unfold`, `key`, `key_vars`, `key_data`, `index`, `index_var`, `coords`, `spatial`, `match_sites`, `match_spatial`, `match_temporal`, `geom_glyph`, `geom_glyph_box`, `geom_glyph_line`, `make_spatial_sf`, `make_temporal_tsibble`, `fill_gaps`, and `scan_gaps`                                                                                |

: (#tab:funs) An overview of functions implemented in the \pkg{cubble} package, categorised into base R, tidyverse, and cubble functions.


| Class                | Methods|
|------------------|------------------------------------------------------|
| `cubble_df`          | `[[<-, dplyr_col_modify, key_data, key_vars, key, print`                                                                                                                                                                                     |
| `spatial_cubble_df`  | `[, names<-,  tbl_sum, dplyr_reconstruct, dplyr_row_slice, face_spatial, face_temporal, unfold, arrange, rename, rowwise, group_by, ungroup, select, spatial, summarise, unfold, update_cubble`                                              |
| `temporal_cubble_df` | `[, names<-, tbl_sum, arrange, dplyr_reconstruct, dplyr_row_slice, face_spatial, face_temporal, unfold, fill_gaps, group_by, ungroup,  rename, rowwise, scan_gaps, select, spatial, summarise, tbl_sum, bind_rows, bind_cols, update_cubble` |

: (#tab:methods) An overview of the methods implemented in the three \code{cubble} classes. Methods are implemented in the \code{cubble\_df} class when they behave consistent across the spatial and temporal cubble; otherwise, they are implemented separately.

The pair of cubble verbs, \code{face_temporal()} and \code{face_spatial()}, pivots the cubble object between its two forms, as illustrated in Figure \ref{fig:face}. The code below connects the a spatial cubble (\code{cb_nested}) and a temporal temporal (\code{cb_long}) introduced in Section \@ref(object) with \code{face_temporal()} and \code{face_spatial()}: 

```{r cubble-fun, echo = TRUE}
identical(face_temporal(cb_nested), cb_long)
identical(face_spatial(cb_long), cb_nested)
```

Both verbs are the exact inverse of each other and apply both functions on a cubble object will result in the object itself:

```{r cubble-fun2, echo = TRUE}
identical(face_spatial(face_temporal(cb_nested)), cb_nested)
identical(face_temporal(face_spatial(cb_long)), cb_long)
```

```{r face, echo = FALSE, fig.align="center", out.width = "100%", fig.cap = "An illustration of the function \\code{face\\_temporal()} and \\code{face\\_spatial()}: \\code{face\\_temporal()} converts a spatial cubble into a temporal cubbl to focus on the temporal variables. Conversely, \\code{face\\_spatial()} transforms a temporal cubble into a spatial one to for focus on the spatial variables."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.001.png"))
```

## Compatibility with tsibble and sf

Analysts often have their preferred spatial or temporal data structure for spatial or temporal analysis, which they may wish to continue using for spatio-temporal analysis. With \code{cubble}, analysts can incorporate the \code{tsibble} class [@tsibble] in a temporal cubble and the \code{sf} class [@sf] in a spatial cubble.

### Using a tsibble object as the temporal component

The \code{key} and \code{index} arguments in a \code{cubble} object corresponds to the \code{tsibble} counterparts and they can be safely omitted, if the temporal component is a \code{tsibble} object, i.e. \code{meteo_ts} in the example below. The \code{tsibble} class (\code{tbl_ts}) from the input will be carried over to the temporal cubble, indicated by the \code{[tsibble]} in the header and in the object class:

```{r echo = TRUE}
ts_nested <- make_cubble(
  spatial = stations, temporal = meteo_ts, coords = c(long, lat))
(ts_long <- face_temporal(ts_nested))
class(ts_long)
```

Methods applies to the \code{tbl_ts} class can also be applied to the temporal cubble objects, for example, checking whether the data contain temporal gaps:

```{r echo = TRUE}
ts_long |> has_gaps()
```


A created temporal cubble can promote its temporal component to a \code{tsibble} object using \code{make_temporal_tsibble()}. See the code example below using the \code{cb_long} object created in Section \@ref(create): 

```{r echo = TRUE}
cb_long |> make_temporal_tsibble() 
```

### Using an sf object as the spatial component

Similarly, the spatial component  of a cubble object can be an \code{sf} object and if the \code{coords} argument is omitted, it will be calculated from the sf geometry. The sf status is signalled by the \code{[sf]} label in the cubble header:

```{r echo = TRUE}
(sf_nested <- make_cubble(
  spatial = stations_sf, temporal = meteo, 
  key = id, index = date))
class(sf_nested)
```

This allows applying functions from the \code{sf} package to a cubble object, for example, to handle coordinate transformation with \code{st_transform}:

```{r echo =TRUE, message=FALSE}
sf_nested |> sf::st_transform(crs = "EPSG:3857")
```

The spatial component of a created \code{cubble} can also be promoted into an \code{sf} object with \code{make_spatial_sf()}:

```{r echo = TRUE}
cb_nested |> make_spatial_sf() 
```


## Comparison to other spatio-temporal classes {#tidyverse}

In \proglang{R}, there are other existing spatio-temporal data structure and this section compares and contrasts \pkg{cubble} with other existing alternative, specifically \pkg{stars} and \pkg{sftime}. The \pkg{stars} package [@stars] uses an array structure, as oppose to tibble, to represent multivariate spatio-temporal data. While both \pkg{stars} and \pkg{cubble} support vector and raster data, it is a matter of choice on which structure to use given the application. Analysts working on satellite imageries may prefer the array structure in \pkg{stars}, while others originally working with spatio-temporal data in 2D data frames may find \pkg{cubble} easier to adopt from their existing computing workflow.

The \pkg{sftime} package [@sftime] also builds from a tibble object and its focus is on handling irregular spatio-temporal data. This means \pkg{sftime} can also handle full space-time grids and sparse space-time layouts represented in \pkg{cubble}, but \pkg{cubble} uses nesting to avoid storing spatial variables repetitively at each timestamp. This provides memory efficiency when data is observed frequent, i.e. daily or sub-daily, or the spatial geometry is expensive to repeat, i.e. polygons or multipolygons. Consider the \code{climate_aus} data in the \pkg{cubble} package with `r nrow(cubble::climate_aus)` stations observed daily in a single year 2020. The created \code{sftime} object is approximately `r library("cubble"); round(object.size(sftime::st_as_sftime(climate_aus))/object.size(climate_aus))` times larger than the corresponding \code{cubble} object (`r round(object.size(sftime::st_as_sftime(climate_aus))/1e6, 2)` MB vs. `r round(object.size(cubble::climate_aus)/1e6, 2)` MB).

# Other features and considerations {#others}

## Data fusion and matching {#matching}

Matching time series from an old list of stations to a new list is a common task in spatio-temporal data analysis. In cubble, matching based on distance and time series feature can be performed using the functions `match_spatial()` and `match_temporal()`. The `match_spatial()` function finds the matched pairs in two cubble objects based on distance between sites:

````
match_spatial(<cubble_obj1>, <cubble_obj2>, ...)
````

Two arguments are available to control the outputs: the argument `spatial_n_group` specifies the number of paired groups to output and the argument `spatial_n_each` specifies the number of each for each item in the first cubble object (default to 1 for one-to-one matching). 

The function `match_temporal()` takes the outputs from spatial matching and calculates a similarity score of the time series between spatially matched pairs. The temporal matching requires two identifiers: one for separating each spatially matched group: `match_id` and one for separating the two data sources: `data_id`. Matching between different variables can be specified using the `temporal_by` argument, similar to the `by` syntax from dplyr's `*_join`.
  
````
match_temporal(
  <obj_from_match_spatial>, 
  data_id = ... , match_id = ..., 
  temporal_by = c("..." = "...")
)
````

The similarity score between two time series is calculated using a matching function, which can be customised by the analysts based on the time series feature relevant to match. The matching function takes two time series as a list and returns a single numerical score. By default, cubble uses a simple peak matching algorithm (`match_peak`) to count the number of peaks in two time series that fall within a specified temporal window. 

## Interactive graphics

The cubble workflow works well with an interactive graphics pipeline (e.g., @buja1988elements; @buja1996interactive;  @sutherland2000orca; @xie2014reactive; @cheng2016enabling). This section describes the linking between a map and multiple time series in a \code{cubble} object using the package \pkg{crosstalk} [@crosstalk], as illustrated in Figure \ref{fig:illu-interactive}. The spatial and temporal cubble can be constructed into a shared crosstalk object to create linking between a map and a time series plot. When a user selects a location on the map (a), the corresponding site is highlighted. This selection activates a row in the spatial cubble, which is then communicated to the temporal cubble, resulting in the selection of all observations with the same ID in (b). Consequently the temporal cubble highlights the corresponding series in the time series plot (c). Linking can also be initiated from the time series plot, by selecting points on the time series, which activates rows with the same ID in the temporal cubble and the corresponding row in the spatial cubble to highlight on the map. 

```{r illu-interactive, echo = FALSE, fig.align="center", out.height = "35%", out.width = "100%", fig.cap = "Linking between multiple plots. The line plots and the map are constructed from shared \\code{crosstalk} objects. When a station is selected on the map (a), the corresponding row in the spatial \\code{cubble} will be activated. This will link to all the rows with the same id in the temporal \\code{cubble} (b) and update the line plot (c)."}
knitr::include_graphics(here::here("figures/diagram-keynotes/‎diagram-keynotes.‎002.png")) 
```

## Spatio-temporal transformations {#st_transformation}

To communicate spatial and temporal information collectively in display,  a few visualisation options are available: one can make faceted maps across time, creating map animations, or constructing interactive graphics to link between map and time series plot. Faceted maps and animation, while commonly used, may not be helpful for comparing across time since eyes need to jump across multiple facets or frames to locate the space before preceiving the changes in time. The glyph map [@Wickham2012-yr] resolves this issue by imposing the time series onto the map as a glyph through coordinate transformation. The transformation uses linear algebra to convert the temporal coordinates (minor coordinates) into the spatial coordinates (major coordinates) and is implemented in the package `GGally` [@ggally] package. The \pkg{cubble} package provides a ggproto implementation, `geom_glyph()`, for glyph maps and it takes four required aesthetics: `x_major`, `y_major`, `x_minor`, and `y_minor`:

```
data |> 
  ggplot() +
  geom_glyph(aes(x_major = ..., x_minor = ..., 
                 y_major = ..., y_minor = ...))
```

Other useful controls over the glyph map includes:
  
  * polar coordinate glyph maps with \code{polar = TRUE}, 
  * adjust glyph size with arguments \code{width} and \code{height},
  * transformation relative to the all series (\code{global_rescale} defaults to \code{TRUE}) or each single series, and 
  * reference boxes and lines with \code{geom_glyph_box()} and \code{geom_glyph_line()}.
  
  
# Applications {#examples}

Five examples are chosen to illustrate different aspects of the \pkg{cubble} package: creating a \code{cubble} object from two Coronavirus (COVID) data tables with the complication of differing location names, using spatial transformations to make a glyph map of seasonal temperature changes, matching river level data and weather station records for analysis of water supply, reading NetCDF format data to reproduce a climate reanalysis plot, and the workflow to create complex interactive linked plots.

## Victoria COVID spatio-temporal incidence and spread {#covid}

Since the start of the pandemic, the Victoria State Government in Australia has been providing daily COVID counts per Local Government Area (LGA). This data can be combined with map polygon data, available from the Australian Bureau of Statistics (ABS), to visualize COVID incidence and spread. In the \pkg{cubble} package, the COVID count data (\code{covid}) and the LGA information (\code{lga}) are available as a \code{tsibble} object and an \code{sf} object respectively.

A cubble object can be created from separate spatial and temporal component using the \code{make_cubble()} function, introduced in Section \@ref(create). The \code{by} argument
is used to specify the joining variable from the two component using the \code{*_join()} \code{by} syntax: 

```{r covid-4, echo = TRUE, warning = TRUE, message= TRUE}
cb <- make_cubble(lga, covid, by = c("lga_name_2018" = "lga"))
```

The warning message suggests the slight difference of LGA encoding used by Victoria government and ABS and prompts analysts to use the function \code{check_key()} to identify the mismatches:

```{r covid-5, echo = TRUE}
(check_res <- check_key(
  spatial = lga, temporal = covid, 
  by = c("lga_name_2018" = "lga")
))
```

The result of the \code{check_key()} function is a list containing three elements: 1) matched keys from both tables, 2) potentially paired keys, and 3) others. Here, the main mismatch arises from the two LGAs: Kingston and Latrobe (Kingston is a LGA in both Victoria and South Australia and Latrobe is a LGA in both Victoria and Tasmania). Analysts can modify the input spatial and temporal data accordingly and recreate the cubble object: 

```{r covid-6, echo = TRUE}
lga2 <- lga |>
  rename(lga = lga_name_2018) |> 
  mutate(lga = ifelse(lga == "Kingston (C) (Vic.)", "Kingston (C)", lga),
         lga = ifelse(lga == "Latrobe (C) (Vic.)", "Latrobe (C)", lga))
  
covid2 <- covid |> filter(!lga %in% check_res$others$temporal)

(cb <- make_cubble(spatial = lga2, temporal = covid2))
```

## Australian historical maximum temperature {#historicaltmax}

The Global Historical Climatology Network (GHCN) provides daily climate measures for stations worldwide. In the \pkg{cubble} package, the dataset \code{historical_tmax} contains daily maximum temperature data for `r nrow(historical_tmax)` stations in Australia, covering two periods: 1971-1975 and 2016-2020. The objective of this example is to compare the changes in maximum temperature between these two periods using a glyph map.

To prevent overlapping of weather stations on the map, we subset the stations based on minimum distance of 50km between them. This can be done by first promoting the spatial cubble to also be an sf object with \code{make_spatial_sf()}, calculating the distance matrix using the sf function \code{st_distance()}, and filtering the stations with dplyr's \code{filter()}:

```{r echo = TRUE}
a <- historical_tmax |> make_spatial_sf() |> st_distance()
a[upper.tri(a, diag = TRUE)] <- 1e6

(tmax <- historical_tmax |> 
  filter(rowSums(a < units::as_units(50, "km")) == 0))
```

Next, daily maximum temperature is averaged into monthly series for each periods in the temporal cubble. The last step with \code{unfold()} moves the two coordinate columns \code{long, lat} into the temporal cubble, preparing the data for the glyph map:

```{r echo = TRUE}
(tmax <- tmax |>
  face_temporal() |> 
  group_by(
    yearmonth = tsibble::make_yearmonth(
      year = ifelse(lubridate::year(date) > 2015, 2016, 1971),
      month = lubridate::month(date))
  )|>
  summarise(tmax = mean(tmax, na.rm = TRUE)) |> 
  mutate(group = as.factor(lubridate::year(yearmonth)),
         month = lubridate::month(yearmonth)) |> 
  unfold(long, lat))
```

A quick check on the number of observations for each location is made, revealing that there are several with less than 24 observations -- these stations lack temperature values for some months. In this example, those stations are removed by switching to the spatial \code{cubble} to operate on the spatial component over time, and then, move back into the temporal \code{cubble} (to make the glyph map):

```{r echo = TRUE}
tmax <- tmax |> 
  face_spatial() |> 
  rowwise() |>
  filter(nrow(ts) == 24) |>
  face_temporal()
```

The following code creates the glyph map (a) in Figure \ref{fig:glyphmap} with additional ggplot2 code for highlighting the single station, Cobar and styling:

````
nsw_vic <- ozmaps::abs_ste |> 
  filter(NAME %in% c("Victoria","New South Wales"))

tmax |> 
  ggplot(aes(x_major = long, x_minor = month, 
             y_major = lat, y_minor = tmax,
             group = interaction(id, group))) + 
  geom_sf(data =  nsw_vic, ...,  inherit.aes = FALSE) + 
  geom_glyph_box(width = 0.8, height = 0.3) + 
  geom_glyph(aes(color = group), width = 0.8, height = 0.3) +
  ...
````

```{r glyphmap, out.width="100%", fig.width=15, fig.height=10, fig.cap="Comparison of average maximum temperature between 1971-1975 and 2016-2020 for 54 stations in Victoria and New South Wales, Australia. (a) and (b): the monthly temperature series for the two periods in a glyph map and for a single station Cobar, highlighted in orange in the glyph map. (c) and (d): the difference series between the two periods (2016s minus 1971s) in a glyph map and for station Cobar. The grey horizontal line marks zero difference. The glyph map displaying the difference series (c) reveals more pronounced changes between the two periods, with many inland locations in New South Wales show an increased temperature in late summer (Jan-Feb) in recent years."}
tmax2 <- tmax |> 
  pivot_wider(id_cols = -yearmonth, names_from = group, values_from = tmax) |> 
  mutate(diff = `2016` - `1971`) |> 
  mutate(x = long + cubble:::rescale11(month) * 0.8/2, 
         y = lat + last(cubble:::rescale11(c(diff, 0)) * 0.3/2))

box_df <- tmax |> filter(id == "ASN00048027")
nsw_vic <- ozmaps::abs_ste |> filter(NAME %in% c("Victoria","New South Wales"))

cobar1 <-  tmax |> filter(id == "ASN00048027") |>
  ggplot(aes(x = month, y = tmax, color = group)) +
  geom_line() +
  scale_color_brewer(palette = "Dark2", guide = "none") +
  scale_x_continuous(
    breaks = seq(1, 12, 1),
    labels = c("J", "F", "M", "A",
               "M", "J", "J", "A",
               "S", "O", "N", "D")
  ) +
  labs(x = "", y  = "Temp (C)") +
  theme_bw() + 
  theme(aspect.ratio = 0.3,panel.grid.minor = element_blank())

cobar2 <- tmax2 |> filter(id == "ASN00048027") |>
  ggplot(aes(x = month, y = diff)) +
  geom_hline(yintercept = 0, color = "grey", linewidth = 0.8) + 
  geom_line() +
  scale_color_brewer(palette = "Dark2", guide = "none") +
  scale_x_continuous(
    breaks = seq(1, 12, 1),
    labels = c("J", "F", "M", "A",
               "M", "J", "J", "A",
               "S", "O", "N", "D")
  ) +
  labs(x = "", y  = "Temp. diff. (C)") +
  theme_bw() + 
  theme(aspect.ratio = 0.3,panel.grid.minor = element_blank())

p1 <- tmax |> 
  ggplot(aes(x_major = long, x_minor = month, 
             y_major = lat, y_minor = tmax,
             group = interaction(id, group))) + 
  geom_sf(data =  nsw_vic, color = "white", 
          fill = "grey95", inherit.aes = FALSE) + 
  geom_glyph_box(width = 0.8, height = 0.3) + 
  geom_glyph(aes(color = group), width = 0.8, height = 0.3) +
  geom_rect(data = box_df,
            aes(xmin = long - 0.6, xmax = long + 0.6,
                ymin = lat - 0.2, ymax = lat + 0.2),
            fill = "transparent", color = "orange", inherit.aes = FALSE) +
  scale_color_brewer("", palette = "Dark2") + 
  coord_sf(xlim = c(141.2, 153.4), ylim = c(-39.2, -28.9)) + 
  ggthemes::theme_map() +
  theme(legend.position = "bottom", legend.text = element_text(size = 10)) + 
  guides(color = guide_legend(override.aes = list(size=2)))

p2 <- tmax2 |> 
  ggplot(aes(x_major = long, x_minor = month, 
             y_major = lat, y_minor = diff)) + 
  geom_sf(data =  nsw_vic, color = "white", 
          fill = "grey95", inherit.aes = FALSE) + 
  geom_path(aes(x = x, y = y, group = id), color = "grey", linewidth = 0.8) + 
  geom_glyph(width = 0.8, height = 0.3) +
  geom_rect(data = box_df,
    aes(xmin = long - 0.6, xmax = long + 0.6,
        ymin = lat - 0.2, ymax = lat + 0.2),
    fill = "transparent", color = "orange", inherit.aes = FALSE) +
  scale_color_brewer("", palette = "Dark2") + 
  coord_sf(xlim = c(141.2, 153.4), ylim = c(-39.2, -28.9)) + 
  ggthemes::theme_map() +
  theme(legend.position = "bottom", legend.text = element_text(size = 10)) + 
  guides(color = guide_legend(override.aes = list(size=2)))

((p1/cobar1) | (p2/cobar2)) + 
  patchwork::plot_layout(guides = "collect") + 
  plot_annotation(tag_levels = 'a')  &
  theme(legend.position='bottom')
```

## River levels and rainfall in Victoria

One common task when working with spatio-temporal data is to match nearby sites. For example, we may want to verify the location of an old list of stations with current stations, or we may want to match the data from different data sources. In this example, we will introduce the spatial and temporal matching in cubble using an example on matching river level data with precipitation in Victoria, Australia.

The water level data collected by the Bureau of Meteorology, can be compared with the precipitation since rainfall can directly impact water level in river. Both `climate_vic` and `river` are cubble objects, and we can obtain a summary of the 10 closest pairs between them:

```{r}
climate_vic <- climate_aus |>
  filter(between(as.numeric(substr(id, 7, 8)), 76, 90)) |>
  mutate(type = "climate")
river <- cubble::river |> mutate(type = "river") 
```


```{r echo = TRUE}
res_sp <- match_spatial(climate_vic, river, spatial_n_group = 10)
print(res_sp, n = 20)
```

The result can also be returned as cubble objects by setting the argument `return_cubble = TRUE`. The output is be a list where each element is a paired cubble object. To combine all the results into a single cubble, you can use `bind_rows()`. In the case when a site in the second cubble (the `river` data here) is matched to two stations in the first cubble (`climate_vic` here), the binding may not be successful since cubble requires unique rows in the nested form. In the summary table above, the river station `226027` is matched to more than one weather station: `ASN00085072` (group 3) and `ASN00085298` (group 5). Similarly, the river station `230200` is matched in group 7 and 8). In such cases, you can either deselect one pair before combining, or work with the list output with the `purrr::map` syntax:


```{r echo = TRUE}
res_sp <- match_spatial(
  climate_vic, river, 
  spatial_n_group = 10, return_cubble = TRUE)
str(res_sp, max.level = 0)
(res_sp <- res_sp[-c(5, 8)] |> bind_rows())
```

For temporal matching, we match the variable `Water_course_level` from the river data to `prcp` in the weather station data. The variable `group` and `types` identify the matching group and the two datasets:

```{r echo = TRUE}
(res_tm <- res_sp |> 
  match_temporal(
    data_id = type, match_id = group,
    temporal_by = c("prcp" = "Water_course_level")))
```

Similarly, the cubble output can be returned using the argument `return_cubble = TRUE`. Here we select the four pairs with the highest number of matching peaks:

```{r echo = TRUE}
res_tm <- res_sp |> 
  match_temporal(
    data_id = type, match_id = group,
    temporal_by = c("prcp" = "Water_course_level"),
    return_cubble = TRUE)
(res_tm <- res_tm |> bind_rows() |> filter(group %in% c(1, 7, 6, 9)))
```

Figure \ref{fig:matching} shows four matched pairs on the map (a) and standardized data as time series (b) with concurrent increasing.

```{r matching, out.width="100%", fig.height = 5, fig.width = 10, fig.cap="Weather stations and river gauges with matched pairs labelled on the map (a) and plotted across time (b). Precipitation and water level have been standardised between 0 and 1 to be displayed on the same scale. The water level reflects the increase in precipitation. The numbers (1, 7, 6, 9) indicate the group index derived from spatial matching, only those that were selectd by temporal matching are shown here."}
res_tm <- res_tm |>  filter(group %in% c(1, 7, 6, 9))

res_tm_long <- res_tm |>  
  face_temporal() |>  
  unfold(group, type) |>  
  group_by(group, type) |>
  mutate(matched = (matched - min(matched, na.rm = TRUE))/ 
           (max(matched, na.rm = TRUE) - min(matched, na.rm = TRUE))) 

vic_map <- ozmaps::abs_ste |> 
  filter(NAME == "Victoria") |> 
  rmapshaper::ms_simplify()  

p1 <-ggplot() + 
  geom_sf(data = vic_map, fill = "grey95", color = "white") + 
  geom_point(data = dplyr::bind_rows(river, climate_vic), 
             aes(x = long, y = lat, color = type), 
             alpha = 0.2, fill = 0.2) +
  geom_point(data = res_tm |> as_tibble(), 
             aes(x = long, y = lat, color = type)) +
  ggrepel::geom_label_repel(
    data = res_tm |> filter(type == "river") |> as_tibble(), 
    aes(x = long, y = lat, label = group)) +
  scale_color_brewer(palette = "Dark2")  + 
  ggthemes::theme_map() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 15)) +
  labs(x = "Longitude", y = "Latitude") + 
  guides(color = guide_legend(override.aes = list(size=5)))

p2 <- res_tm_long |>  
  ggplot(aes(x = date, y = matched, group = type,color = type)) + 
  geom_line() + 
  facet_wrap(vars(group)) + 
  scale_color_brewer(palette = "Dark2", guide = "none") + 
  theme_bw() + 
  labs(x=  "date") + 
  scale_x_date(date_labels = "%b") + 
  labs(x = "Week", y = "Precipitation/ water level")

(p1 | p2) + 
  patchwork::plot_layout(guides = "collect") + 
  plot_annotation(tag_levels = 'a')&
  theme(legend.position = "bottom") 
```


## ERA5: climate reanalysis data

The ERA5 reanalysis [@hersbach2020era5] provides hourly estimates of atmospheric, land and oceanic climate variables on a global scale. The hourly pressure level data in the NetCDF format can be downloaded from Copernicus Climate Data Store (CDS) or via the \pkg{ecmwfr} package [@ecwmfr]. This example reproduces the row created from ERA5 reanalysis data shown in Figure 19 by @hersbach2020era5. The plot shows the southern polar vortex splitting into two on 2002-09-26, and further splitting into four on 2002-10-04. Further explanation of why this is interesting can be found in the figure source, and also in @simmons2020global and @simmons2005ecmwf.

 The following code converts a NetCDF object of class \code{ncdf4} [@ncdf4] into a cubble object:

```{r echo = TRUE}
raw <- ncdf4::nc_open(here::here("data/era5-pressure.nc"))
```

Analysts can extract a subset of the NetCDF data with the arguments \code{vars}, \code{long_range} and \code{lat_range}. In this example, the variables q (specific humidity) and z (geopotential) are selected and the coordinates are subsetted to every degree in longitude and latitude: 

```{r echo = TRUE}
(dt <- as_cubble(
  raw, vars = c("q", "z"),
  long_range = seq(-180, 180, 1), lat_range = seq(-88, -15, 1)))
```

Once the NetCDF data is coerced into a cubble object, subsequent analysis can be conducted to filter on the date of interest, scale the variable specific humidity and create visualisation in ggplot as in Figure \ref{fig:netcdf}.

```{r netcdf, out.width="100%", fig.height = 4, fig.width = 10, fig.cap = "A reproduction of the second row (ERA5 data) of Figure 19 in Hersbach et al (2020) to illustrate the break-up of sourthern polar vortex in late September and early October 2002. The polar vortex, signalled by the high specific humidity, splits into two on 2002-09-26 and further splits into four on 2002-10-04.", dev = "png"}
date <- c("2002-09-22", "2002-09-26", "2002-09-30", "2002-10-04") |> as.Date()
res <- dt |> 
  face_temporal() |> 
  filter(lubridate::date(time) %in% date) |>
  unfold(long, lat) |> 
  mutate(q = q* 10^6)

con <- rnaturalearth::ne_coastline("small", returnclass = "sf")
box <- st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = -15), crs = st_crs(con)) 
sf_use_s2(FALSE)
country <- con |> st_geometry() |> 
  st_crop(box) |> 
  st_cast("MULTILINESTRING")

res |> 
  ggplot() +
  # q for specific humidity
  geom_point(aes(x = long, y = lat, color = q)) + 
  #geom_tile(aes(x = long, y = lat, fill = q), color = "transparent") +
  # z for geopotential
  geom_contour(data = res, aes(x = long, y = lat, z = z),
               color = "grey20", binwidth = 4000, linewidth = 0.5) +
  geom_sf(data = country , alpha = 0.5, fill = "transparent", color = "lightgreen") +
  coord_sf(
    crs = "+proj=stere +lat_0=-90 +lon_0=-180 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs", default_crs = st_crs(4326), clip = "off") +
  theme_bw() +
  theme(legend.position = "bottom",
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank()) +
  facet_wrap(vars(as.Date(time)), nrow = 1)+  
  colorspace::scale_color_continuous_sequential("Purple-Yellow", name = "Specific humidity") + 
  theme(legend.text = element_text(size = 13),
        legend.title = element_text(size = 13)) + 
  labs(x ="", y = "")
```

## Australian temperature range

Interactive graphics can be useful because they make it possible to look at the data in multiple ways on-the-fly. This is especially important for spatio-temporal data, where we would like to interactively connect spatial and temporal displays. This example describes the process of using the \pkg{cubble} package with the \pkg{crosstalk} package to build an interactive display connecting a map of Australia, with ribbon plots of temperature range observed at the stations. The purpose is to explore the variation of monthly temperature range over the country. Figure \ref{fig:interactive-linking} shows three snapshots of the interactivity.

The key steps are to convert both the nested and long forms of the data into shared \code{crosstalk} objects, and to plot these side-by-side. The two are linked by the station identifier.

``` r
clean <- climate_full |> ...

nested <- clean |> SharedData$new(~id, group = "cubble")
long <- face_temporal(clean) |> SharedData$new(~id, group = "cubble")

p1 <- nested |> ...
p2 <- long |> ...

crosstalk::bscols(plotly::ggplotly(p1), plotly::ggplotly(p2), ...)

```

Plot (a) shows the initial state of the interactive display: all locations are shown as dots on the map, coloured by temperature range, and the right plot shows the ribbons representing maximum to minimum for all stations. In plot (b) the "Mount Elizabeth" station, which shows a high variance colour on the initial map, is selected on the map and this produces the ribbon on the right. In plot (c) the lowest temperature in August is selected, which is "Thredbo" station on the left map. It was surprising to us that this was not a station in Tasmania, so for comparison a station in Tasmania is selected on the map to show in relation to Thredbo. We can see that Thredbo has a bigger winter dip in temperature, and although Tasmania is cold generally, it's temperatures are more constant.

```{r interactive-linking, echo = FALSE, out.width="100%", out.height="23%", fig.retina = 2, dpi = 300, fig.cap = "Exploring temperature variation using linking of a map and seasonal display. Each row is a screen dump of the process. The top row shows all locations and all temperature profiles. Selecting a particular location on the map (here Mount Elizabeth) produces the plot in the second row. The maximum and minimum temperatures are shown using a ribbon. The bottom row first selects the lowest temperature in August in the seasonal display, which highlights the corresponding station on the map (Thredbo). Another  station, located in the Tasmania Island, is then selected to compare its temperature variation with the Thredbo station.", fig.show='hold'}
knitr::include_graphics(here::here("figures/linking.png"))
knitr::include_graphics(here::here("figures/linking-north.png"))
knitr::include_graphics(here::here("figures/linking-lower.png"))
```

# Conclusion {#conclude}

This paper presents the \proglang{R} package \pkg{cubble} for organizing, wrangling and visualizing spatio-temporal data. The package introduces a new data class, \code{cubble}, consisting of two subclass, spatial cubble and a temporal cubble, to organise spatio-temporal data in two different formats within the tidy data framework. The data structure and functions introduced in this package can be used and combined with existing spatial and temporal data analysis packages such as \pkg{sf} and \pkg{tsibble}, data wrangling packages such as \pkg{dplyr}, and visualization packages such as \pkg{ggplot2}, \pkg{plotly}, and \pkg{leaflet}.

The paper includes numerous examples to illustrate the utility of \pkg{cubble} as a data structure for spatio-temporal analysis. These examples cover different tasks of a typical analysis workflow: handling data with spatial and temporal misalignment, matching data from multiple sources, and creating both static and interactive spatio-temporal visualisation. For future directions, other commonly-used spatial or temporal data structures can be integrated into \pkg{cubble} to extend analysts' familiar spatial and temporal toolkit to spatio-temporal.

# Acknowledgement

This work is funded by a Commonwealth Scientific and Industrial Research Organisation (CSIRO) Data61 Scholarship and started while Nicolas Langrené was affiliated with CSIRO's Data61. The article is created using the package \pkg{knitr} [@knitr] and \pkg{rmarkdown} [@rmarkdown] in \proglang{R} with the \code{rticles::jss_article} template. The source code for reproducing this paper can be found at: https://github.com/huizezhang-sherry/paper-cubble.
