---
title: "4-examples"
output: html_document
---

# Examples {#examples}

The five examples here are chosen to illustrate these aspects of using cubble: creating a cubble from two COVID data tables with the complication of differing location names, using spatial transformations to make a glyph map of seasonal temperature changes over years, aggregating information spatially to explore precipitation patterns, matching river level data and weather station records for analysis of water supply, reading netCDF format data to reproduce a climate reanalysis plot, and the workflow to create complex interactive linked plots. (There is an additional example and figures in the Appendix, and more examples in the package vignettes.)

## Victoria COVID spatio-temporal incidence and spread {#covid}

Since the start of the pandemic, the Victoria State Government in Australia has provided daily COVID counts by local government area (LGA). This data can be used to visualise COVID incidence and spread spatially, when combined with map polygon data available from the Australian Bureau of Statistics. These different sources need to be combined for the analysis, by matching the LGA names. Here is how to do this with \pkg{cubble}, including how to handle mismatches arising from different names of the same LGAs in the two tables. The COVID data is a `csv` and looks like:  

```{r eval = FALSE}
library(tidyverse)
#https://www.coronavirus.vic.gov.au/victorian-coronavirus-covid-19-data
raw <- read_csv(here::here("data/NCOV_COVID_Cases_by_LGA_Source_20220324.csv"),
                  col_names = c("date", "postcode", "source", "lga"), skip = 1)

covid <- raw %>%
  count(date, lga, source, postcode) %>%
  filter(date >= as.Date("2022-01-01")) %>%
  filter(source == "Contact with a confirmed case") %>%
  group_by(date, lga, source) %>%
  count() %>%
  ungroup(date) %>%
  mutate(roll_mean = zoo::rollmean(n, k = 14, fill = NA)) %>%
  tsibble::as_tsibble(key = lga, index = date) %>%
  tsibble::fill_gaps(.full = TRUE)
save(covid, file = here::here("data/covid.rda"))
```

```{r}
load(here::here("data/covid.rda"))

lga <- strayr::read_absmap("lga2018") %>%
  rename(lga = lga_name_2018) %>%
  filter(state_name_2016 == "Victoria") 
```

```{r echo = TRUE}
covid %>% head(5)
```

and the spatial polygons are an ESRI shapefile that looks like:

```{r echo = TRUE}
lga %>% head(5)
```

The function \code{as_cubble()} is used to create a \code{cubble} object from the two spatial and temporal tables, and requires specifying the arguments (\code{key}, \code{index}, and \code{coords}) (as described in Section \@ref(create)). It will automatically try to match the sites in both tables and will show a warning message when there are mismatches, as shown below:

```{r echo = TRUE, warning = TRUE, message= TRUE}
cb <- as_cubble(
  list(spatial = lga, temporal = covid),
  key = lga, index = date, coords = c(cent_long, cent_lat)
  )
```

It can be seen that there are two-way mismatches -- LGAs in the COVID data that don't match with LGAs in the spatial polygon data, and vice versa. The mismatches can be identified by using the \code{output = "unmatch"} argument. <!--Note that \pkg{cubble} will attempt to pair the unmatched sites, these are shown separately from the ones that cannot be paired.-->

```{r echo = TRUE}
pair <- as_cubble(
  list(spatial = lga, temporal = covid),
  key = lga, index = date, coords = c(cent_long, cent_lat),
  output = "unmatch"
  )

pair
```

With this information both tables can be fixed, to create the desired cubble, as follows:

```{r echo = TRUE}
lga <- lga %>%
  mutate(lga = ifelse(lga == "Kingston (C) (Vic.)", "Kingston (C)", lga),
         lga = ifelse(lga == "Latrobe (C) (Vic.)", "Latrobe (C)", lga)) %>%
  filter(!lga %in% pair$others$spatial)

covid <- covid %>% filter(!lga %in% pair$others$temporal)

cb <- as_cubble(data = list(spatial = lga, temporal = covid),
                key = lga, index = date, coords = c(cent_long, cent_lat))
```

## Australian historical maximum temperature {#historicaltmax}

```{r}
load(here::here("data/historical_tmax.rda"))
```


The Global Historical Climatology Network (GHCN) provides daily climate measures from stations across the world. The data used here (\code{historical_tmax}) is a subset extracted using the `rnoaa` package, containing the records of maximum temperature for `r nrow(historical_tmax)` Australian stations from `r range(historical_tmax$first_year)[1]` through `r range(historical_tmax$first_year)[2]` and provides information also on the latitude, longitude and elevation of each of the  stations. <!-- This data  is already cast into a \code{cubble} data object (please see Appendix X for the code to extract  the data from XX and prepare the data into \code{cubble} form), with \code{id} as the key, \code{date} as the index, and \code{c(longitude, latitude)} as the coordinates.--> The goal of this example is to compare the monthly average maximum temperature between two periods, 1971-1975 and 2016-2020, for stations in Victoria and New South Wales, using a glyph map.

First, the stations need to be filtered to those in NSW and Victoria, by using the station identifiers, stored within the 11 digits of the \code{id} variable entries. The country code is in the first 5 digits (Australia is represented by "ASN00") and the next 6 digits encode the station following the [Australian Bureau of Meteorology (BOM)](http://www.bom.gov.au/climate/cdo/about/site-num.shtml) coding protocols. New South Wales stations correspond to entries in the range 46-75 and the Victorian stations to 76-90. Filtering Victoria and New South Wales stations is a *spatial operation* and hence uses the \code{cubble} nested form:

```{r echo = TRUE}
tmax <- historical_tmax %>%
  filter(between(stringr::str_sub(id, 7, 8), 46, 90))
```

Next, a monthly maximum average temperature is  calculated for both periods. This is a *temporal operation* requiring a switch into the long cubble form, and creating a new indicator for the two time periods, before the calculation:

```{r echo = TRUE}
tmax <- tmax %>%
  face_temporal() %>% 
  group_by(month = lubridate::month(date),
         group = as.factor(
           ifelse(lubridate::year(date) > 2015,
           "2016 ~ 2020", "1971 ~ 1975"))) %>%
  summarise(tmax = mean(tmax, na.rm = TRUE))
```

A quick check on the number of observations for each location is made, revealing that there are several with less than 24 -- these lack temperature values for some months. These stations are removed, by switching to a long cubble to operate on the spatial component over time, and then back to the nested cubble (to make the glyph map):

```{r echo = TRUE}
tmax %>% 
  face_spatial() %>% 
  mutate(n = nrow(ts)) %>%
  arrange(n) %>%
  pull(n) %>% 
  head(10)

tmax <- tmax %>% 
  face_spatial() %>% 
  filter(nrow(ts) == 24) %>%
  face_temporal()
```

To create a glyph map of the monthly series overlaid on the map (Figure \ref{fig:basic-manip}), requires that the spatial variables be unfolded with the temporal variables. Both of the major (\code{long}, \code{lat}) and minor (\code{month}, \code{tmax}) coordinates need to be on the same table. The \code{geom_glyph()} function does both the transformation and the plotting. (An inset of the glyph for one station is shown in the top left corner.) 

```{r eval = FALSE, echo = TRUE}
nsw_vic <- ozmaps::abs_ste %>%
  filter(NAME %in% c("Victoria", "New South Wales"))

ggplot() +
  geom_sf(data = nsw_vic,
          fill = "transparent", color = "grey",
          linetype = "dotted") +
  geom_glyph(data = tmax,
             aes(x_major = long, x_minor = month,
                 y_major = lat, y_minor = tmax,
                 group = interaction(id, group), color = group),
             width = 1, height = 0.5) +
  ...
```

```{r create-inset, eval = FALSE}

tmax %>% filter(id == "ASN00048027") %>%
  ggplot(aes(x = month,
             y = tmax,
             color = group)) +
  geom_line(size = 1.5) +
  scale_color_brewer(palette = "Dark2", 
                     guide = "none") +
  scale_x_continuous(breaks = seq(1, 12, 1), 
                     labels = c("J", "F", "M", "A",
                                "M", "J", "J", "A",
                                "S", "O", "N", "D")) +
  labs(x = "", y  = "Temp (C)", 
       title = "ASN00048027: Cobar") +
  theme_bw() +
  theme(
    aspect.ratio = 0.3,
    axis.text = element_text(size = 20),
    title =  element_text(size = 20)
  )

#ggsave(filename = here::here("figures/basic-manip-inset.png"), width = 7)
```


```{r basic-manip, out.width="50%", fig.height = 6, fig.width = 5, fig.cap="A glyph map of the monthly maximum average temperature for weather stations in  Victoria and New South Wales for the periods (1971-1975, 2016-2020). The corresponding average time series for the Cobar station are display on the top left corner. From the glyph map we can observe that the monthly trend is similar for all locations (low in the winter, high in the summer), and small increased temperatures, particularly in late summer can be seen at most stations."}
tmax <- tmax %>% unfold(long, lat)

nsw_vic <- ozmaps::abs_ste %>% 
  filter(NAME %in% c("Victoria", "New South Wales"))

p1 <- ggplot() + 
  geom_sf(data = nsw_vic, fill = "grey95", 
          color = "white", size=2) + 
  geom_glyph(data = tmax, 
             aes(x_major = long, x_minor = month, 
                 y_major = lat, y_minor = tmax,
                 group = interaction(id, group), 
                 color = group),
             width = 1.2, height = 1, alpha=0.5, 
             size=1.1) +
  scale_color_brewer("", palette = "Dark2") + 
  theme_bw() + 
  coord_sf(xlim = c(141, 154), ylim = c(-39, -28.5)) + 
  ggthemes::theme_map() +
  theme(legend.position = "bottom") #+
  #labs(x = "Longitude", y = "Latitude")

box_df <- tmax %>% 
  face_spatial() %>% 
  filter(id == "ASN00048027")
single <- tibble::tibble(img = here::here("figures/basic-manip-inset.png"))

p1 +
  geom_rect(data = box_df,
            aes(xmin = long - 0.6, xmax = long + 0.6,
                ymin = lat - 0.12, ymax = lat + 0.35),
            fill = "transparent", color = "black") +
  ggimg::geom_point_img(
    data = single, aes(x = 143.7, y = -30, img = img), size = 6)

```

Glyph maps work well to explore temporal patterns across spatial locations, particularly when the spatial locations are gridded. Here they are irregularly spaced, which can result in overlapping glyphs obscurring each other. To fix this one could aggregate data from nearby stations. An example is included in the Appendix. 
