---
title: "2-the-cubble-pkg"
output: pdf_document
---

# The cubble package

\textcolor{red}{more beginning} In cubble data can represented in two formats: nested form and long form, and Figure \ref{fig:illu-cubble} sketches the two forms with the associated attributes. The decision on which form to use in data manipulation is output-oriented, meaning analysts need to first think about whether the output of an operation is identified only by the spatial identifier, or a combination of spatial and temporal identifier. The nested cubble is suitable for working with operations that are only identified by the site and this type of operation can be a pure manipulation of time invariant variables, or an operation that summarises time varying variables into site. Underneath the nested form, a cubble is built from a \code{rowwise_df} data frame where each site forms a separate group. This structure simplifies the calculation that involves temporal variables by avoiding the use of \code{purrr::map()} syntax when working with list-column.

For those operations whose output involves both a spatial and temporal identifier, long form should be used. The long form uses a  \code{grouped_df} data frame to forms all the time of a site as a group. Time invariant variables are stored separately as an special attribute of the long cubble. This design avoids repeating the spatial variables at each time stamp while not dropping information from spatial variables.

```{r illu-cubble, echo = FALSE, fig.align="center", out.width = "100%", fig.cap = "An illustration of the nested and long form in cubble. The nested form defines each site in a row and nests the time varying variables into a single column \\code{ts}. The long form cubble uses \\code{id} and \\code{t} to identify each row and store the time invariant variables as an attribute, \\code{spatial}."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.002.png"))
```

## Create a cubble in the nested form

\textcolor{red}{more beginning} A cubble can be created with \code{as_cubble()} by supplying the three key components: \code{key} as the spatial identifier; \code{index} as the temporal identifier; and a vector of \code{coords} in the order of longitude and latitude. The naming of \code{key} and \code{index} follows the convention in the \pkg{tsibble} package. \textcolor{red}{give some context of the data about to be used: a subset of a larger data etc} Below is an example of creating a cubble and by default, the cubble created is in the nested form: 

```{r echo = TRUE}
cubble_nested <- cubble::climate_flat %>%
  as_cubble(key = id, index = date, coords = c(long, lat))
cubble_nested
```

There are a few information in the cubble header: the name of the \code{key} variable: \code{id} and its number: 5, the bounding box: \code{[115.97, -32.94, 133.55, -12.42]} , and also the name of variable nested in the \code{ts} column with its type: \code{date [date], prcp [dbl], tmax [dbl], tmin [dbl]}. 

## Stretch a nested cubble into the long form

The long cubble is suitable to manipulate the time dimension of the data and  \code{stretch()} switches the nested cubble into the long cubble. It first extracts all the spatial variables into a separate tibble and then unnests the \code{ts} column. The spatial variables are then attached as an attributes of the long cubble and can be accessed through `spatial()`:

```{r echo = TRUE}
cubble_long <- cubble_nested %>% stretch(ts)
cubble_long

spatial(cubble_long)
```

Notice that the third line in the header now shows the name and type of spatial variables: \code{lat [dbl], long [dbl], elev [dbl], name [chr], wmo_id [dbl]}.

## Tamp a long cubble back to the nested form

Manipulation on the spatial and temporal dimension can be an iterative process and analysts may need to go back and forth between the nested and long cubble. \code{tamp()}, an inverse of \code{stretch()}, switches a long cubble to a nested cubble:

```{r echo = TRUE}
cubble_back <- cubble_long %>% tamp()
cubble_back
```

## Migrate spatial variables to a long cubble

Analysts may need the time invariant and varying variable to be in the same table to apply certain function. In cubble, this can be done through \code{migrate()}, which moves the time invariant variables into the long cubble:

```{r echo = TRUE}
cubble_mig <- cubble_long %>% migrate(long, lat)
cubble_mig
```

Notice that these added time invariant variables will not be remembered by cubble and will disappear if switched to the nested form and then switched back. Hence, \code{migrate()} should usually be used as the last step of the analysis:

```{r echo = TRUE}
cubble_mig %>% tamp() %>% stretch()
```

## Compatibility with existing packages

\textcolor{red}{A beginning sentence that summarises the subsection}. 
\textcolor{red}{Given more details and examples when going through each subsection}


### dplyr

Building from an \code{tbl_df} class, cubble has implemented methods for \pkg{dplyr} generics, which includes:

  - basic: mutate, filter, summarise, select, arrange, rename, left_join
  - grouping: group_by, ungroup
  - slice family: slice_head, slice_tail, slice_sample, slice_min, slice_max

### tsibble

Cubble is also compatible with \pkg{tsibble}. When creating a cubble from a tsibble, only the \code{coords} argument needs to be specified: 

```{r echo = TRUE}
# casting a tsibble into cubble
dt <- climate_flat %>% 
  tsibble::as_tsibble(key = id, index = date) %>% 
  cubble::as_cubble(coords = c(long, lat))
dt
```

In the created nested form, each element of the list-column \code{ts} is of \code{tbl_ts} class and existing operations on the tsibble class can still be applied:
  
```{r echo = TRUE}
# add station-based features in the nested form.
dt %>% 
  mutate(fabletools::features(ts, tmax, list(tmax_mean = mean, tmax_var = var)))
```

### sf and s2

Cubble is compatible with simple feature geometry list-column (\code{sfc}) in \pkg{sf} and  \code{s2_lnglat} vector in \pkg{S2} in the nested form. After creating a cubble, analysts can add the geometry vectors as needed to perform spatial operations: 

```{r echo = TRUE}
library(s2)
# create a cubble
cb <- climate_flat %>% 
  cubble::as_cubble(key = id, index = date, coords = c(long, lat))

# western australia map
wa <- ozmaps::abs_ste %>% filter(NAME == "Western Australia")

# create a `s2_lnglat` vector based on long and lat and filter stations in wa
cb %>%
  mutate(ll = s2_lnglat(long, lat)) %>% 
  filter(s2_within(ll, wa))
```

```{r echo = TRUE}
library(sf)
# simplify australia map
aus <- ozmaps::abs_ste %>% rmapshaper::ms_simplify(keep = 0.01)

dt <- cb %>%
  mutate(
    # create `sfc` column based on long and lat
    ll = st_sfc(
      purrr::map2(long, lat, ~st_point(c(.x, .y))),
      crs = st_crs(aus)),
    # append state multi-polygon based on the `sfc` created
    state = aus$geometry[st_within(ll, aus, sparse = FALSE)],
    # adopt a different projection: lambert conformal conic (EPSG:3112)
    state = st_transform(state, crs = "EPSG:3112"))

dt
```


### netcdf

NetCDF data has two main components: *dimension* for defining the spatio-temporal grid (longitude, latitude, and time) and *variable* that populates the defined grid. Attributes are usually associated with dimension and variable in the NetCDF format data and a [metadata convention for climate and forecast](http://cfconventions.org/) has been designed to standardise the format of the attributes. A few packages in R exists for manipulating NetCDF data and this includes a high-level R interface: \pkg{ncdf4} [@ncdf4], a low-level interface that calls C-interface: \pkg{RNetCDF} [@rnetcdf; @michna2013rnetcdf], and a tidyverse implementation: \pkg{tidync} [@tidync].

Cubble provides an \code{as_cubble()} method to coerce the \code{ncdf4} class from the \pkg{ncdf4} package into a \code{cubble}. It maps each combination of longitude and latitude into an \code{id} as the \code{key}:

```{r echo = TRUE, eval = FALSE}
# read in the .nc file as a ncdf4 class
raw <- ncdf4::nc_open(here::here("data/era5-pressure.nc"))

# convert the variable q and z in the ncdf4 into a cubble
dt <- as_cubble(raw, vars = c("q", "z"))
```

Memory limit with NetCDF data in cubble depends on longitude grid point x latitude grid point x time grid point x number of variable. Cubble can handle slightly more than 300 x 300 (longitude x longitude) grid points for 3 variables in one year and spatial grid can be reduced to trade for longer time period and more variables. A 300 by 300 spatial grid can be a bounding box of [100, -80, 180, 0] at 0.25 degree resolution or a global bounding box [-180, -90, 180, -90] at 1 degree resolution. Subsetting longitude and latitude grid is available through \code{long_range} and \code{lat_range} if the NetCDF file has finer resolution than needed.

```{r eval = FALSE, echo = TRUE}
# Assume my_ncdf has bounding box of [-180, -90, 180, -90] 
# at 0.25 degree resolution and subset it to have 
# 1 degree resolution:
dt <- as_cubble(my_ncdf, vars = c("q", "z"), 
                long_range = seq(-180, 180, 1), 
                lat_range = seq(-90, 90, 1))
```
