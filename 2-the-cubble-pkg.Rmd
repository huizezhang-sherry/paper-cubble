---
title: "2-the-cubble-pkg"
output: pdf_document
---

# The cubble package

Spatio-temporal data usually come in various forms and Figure \ref{fig:illu-input} shows four examples of this. These four examples show some common characters of the spatio-temporal data: 1) a spatial identifier, that uniquely identifies each site, 2) a temporal identifier, that prescribes the time stamp each site is recorded, 3) Coordinates, comprising of latitude and longitude, that locate each site on the map. These identifiers will be the building blocks for cubble. Spatio-temporal data can also be thought of as a data cube with three axes: id, time, and variable. Notice that in the time-variable face, time invariant variables share the same value across all the time stamps while time varying variables have values varying across time. This heterogeneity will be used to split the data into two forms in cubble.

```{r illu-input, echo = FALSE, out.width = "100%", fig.cap="An illustration of different spatio-temporal data format: (1) a single table for all the variables; (2) separate tables for spatial and temporal variables; (3) a table of metadata used to query the database and a separate table for queried data; and (4) an array data structure of cube or hypercube.", fig.align='center', out.height = "40%"}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.001.png"))
```

In a cubble, there are two forms: nested form and long form, and Figure \ref{fig:illu-cubble} sketches the two forms along with the associated attributes. The decision on which form to use is output-oriented, meaning analysts need to first think about whether the output of a particular operation is identified only by the spatial identifier, or a combination of spatial and temporal identifier. The nested cubble is suitable for working with operations that are only identified by the site and this type of operation can be a pure manipulation of spatial variables, or a summary of temporal variables by site (i.e. the output of counting the number of raining day is only identified by sites and hence should be performed with the nested form). Underneath the nested form, a cubble is built from a row-wise dataframe (\code{rowwise_df}) where each site forms a separate group. This structure simplifies the calculation that involves temporal variables by avoiding the use of \code{map} syntax when working with list-column.

For those operations whose output involves both a spatial and temporal dimension, long form should be used. The long form is identified by both the spatial and temporal identifier and adopts a grouped dataframe (`grouped_df`) to forms each site as a group. Spatial variables are stored separately in a \pkg{tibble} as an special attribute of the long cubble. This design avoids repeating the spatial variables at each time stamp while not dropping information from spatial variables.

```{r illu-cubble, echo = FALSE, fig.align="center", out.width = "100%", fig.cap = "An illustration of the nested and long form in cubble. The nested form defines each site in a row and nests the time varying variables into a single column \\code{ts}. The long form cubble uses \\code{id} and \\code{t} to identify each row and store the time invariant variables as an attribute, \\code{spatial}."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.002.png"))
```

## Create a cubble in the nested form

\code{as_cubble()} creates a cubble by supplying the three key components: \code{key} as the spatial identifier; \code{index} as the temporal identifier; and a vector of \code{coords} in the order of longitude first and then latitude. The naming of \code{key} and \code{index} follows the convention in the \pkg{tsibble} package. The cubble created by default is in the nested form. Below is an example of creating a cubble:

```{r echo = TRUE}
cubble_nested <- cubble::climate_flat %>%
  as_cubble(key = id, index = date, coords = c(long, lat))
cubble_nested
```

There are a few information in the cubble header: the name of the \code{key} variable (`id`) and its number (5), bounding box (`[115.97, -32.94, 133.55, -12.42]`), and also the name of variable nested in the \code{ts} column with its type: \code{date [date], prcp [dbl], tmax [dbl], tmin [dbl]}. 

## Stretch a nested cubble into the long form

The long cubble is suitable to manipulate the time dimension of the data. The function \code{stretch()} switches the nested cubble into the long cubble by first extracts all the spatial variables into a separate tibble and store in the \code{spatial} attribute and then unnests the \code{ts} column:

```{r echo = TRUE}
cubble_long <- cubble_nested %>% stretch(ts)
cubble_long
```

Notice here that the third line in the header now shows the name and type of spatial variables: \code{lat [dbl], long [dbl], elev [dbl], name [chr], wmo_id [dbl]}.

## Tamp a long cubble back to the nested form

Manipulation on the spatial and temporal dimension can be an iterative process. Many times, analysts will need to go back and forth between the nested and long cubble. \code{tamp()} inverses the \code{stretch()} that introduced in the previous section, to switch from a long cubble to the nested cubble:

```{r echo = TRUE}
cubble_back <- cubble_long %>% tamp()
cubble_back
```

## Migrate spatial variables to a long cubble

Some functions require time invariant variables to be in the same table as the time varying ones. In cubble, this can be done through \code{migrate()}, which moves the time invariant variables into the long cubble:

```{r echo = TRUE}
cubble_mig <- cubble_long %>% migrate(long, lat)
cubble_mig
```

Notice that these added time invariant variables will not be remembered the cubble and will disappear if switched to the nested form and then switched back. Hence they should most likely been used at the last step of the analysis:

```{r echo = TRUE}
cubble_mig %>% tamp() %>% stretch()
```

## Compatibility with existing packages

Building from an \code{tbl_df} class, cubble has implemented methods for \pkg{dplyr} generics, which includes:

  - basic: mutate, filter, summarise, select, arrange, rename, left_join
  - grouping: group_by, ungroup
  - slice family: slice_head, slice_tail, slice_sample, slice_min, slice_max

\pkg{cubble} is also compatible with \pkg{tsibble}. When creating a cubble from a tsibble, Only the \code{coords} argument need to be specified: 

```{r echo = TRUE}
# casting a tsibble into cubble
dt <- climate_flat %>% 
  tsibble::as_tsibble(key = id, index = date) %>% 
  cubble::as_cubble(coords = c(long, lat))
dt
```

In the created nested form, each element of the list-column \code{ts} is of \code{tbl_ts} class so that existing operations on the tsibble class can still be applied:
  
```{r echo = TRUE}
# add station-based features in the nested form.
dt %>% 
  mutate(fabletools::features(ts, tmax, list(tmax_mean = mean, tmax_var = var)))
```

