---
title: "2-the-cubble-pkg"
output: pdf_document
---

# The cubble package {#cubble}

A cubble object is an S3 object [@advr] built on top of the \code{tibble} class to organise spatio-temporal data. Since spatial and temporal variables are usually recorded in different observational units, the \code{cubble} class uses an attribute, **form**,  to arrange the data into a spatial or temporal tidy way. The **form** attributes can take a value of either "nested" or "long". The nested cubble is a subclass of \code{rowwise_df}. It arranges each spatial site in a row and uses list columns to store feature geometry and temporal information. The long cubble, instead, is a subclass of \code{grouped_df}, which expands the temporal information into the long form and stores the spatial information in a unique attribute to the long cubble, **spatial**.

<!-- A cubble is a data object that arranges spatio-temporal information in a spatial and temporal tidy way. It uses two forms to achieve this: the nested form presents the spatial variables, including the feature geometry, and nests the temporal information for spatial wrangling. The long form expands the temporal information and stashes the spatial variables for temporal wrangling. A benefit of cubble is that it interfaces directly with existing spatial and temporal data wrangling packages. For example, operations on feature geometry from the \code{sf} package and temporal operations, i.e., temporal ordering, duplication check. and gap filling, from the \code{tsibble} package.  -->



The main functions in the cubble package are \code{as_cubble()}, \code{face_spatial()}, \code{face_temporal()}, and \code{unfold()}. The following sections explain their role, why the new cubble structure is needed and how the package relates to existing packages for spatial and temporal data analysis.

The dataset `climate_flat` is used to illustrate \pkg{cubble} functionality. This is a subset from the ORIGIN and contains the spatial variables, station id, latitude, longitude, elevation, station name, World Meteorology Organisation ID, in additional to daily temporal information,  maximum and minimum temperature values and precipitation records for 2020. The first five rows of `climate_flat` are shown below:

```{r}
cubble::climate_flat
```

## Create a cubble {#create}

A cubble can be created from various common spatio-temporal data formats, including basic R objects like tibble, tsibble, sf. Section \@ref(covid) describes converting multiple tables into a cubble object and Section \@ref(netcdf) illustrate how to convert a netCDF object.

The function \code{as_cubble()} is used to create a cubble with three arguments: \code{key} as the spatial identifier; \code{index} as the temporal identifier; and a vector of \code{coords} in the order  (longitude, latitude). The arguments \code{key} and \code{index} follow the wording in \pkg{tsibble} to describe the temporal order and multiple series while \code{coords} specifies the spatial location of each site. The code below creates a cubble out of \code{climate_flat} (a single tibble) with \code{id} as the key, \code{date} as the index, and \code{c(long, lat)} as the coordinates:

```{r echo = TRUE}
cubble_nested <- climate_flat |>
  as_cubble(key = id, index = date, coords = c(long, lat))
cubble_nested
```

Printing a cubble provides some information about the data. \code{id} is the variable name to identify each location and there are five unique locations. The bounding box is \code{[115.97, -32.94, 133.55, -12.42]} and provides information about the coordinates in the data set. The third row shows the name and type of all variables nested in the \code{ts} column. In this example, it includes \code{date [date], prcp [dbl], tmax [dbl], tmin [dbl]}.

A cubble object is an extension of a \code{rowwise_df} object where each row forms a group. All the temporal variables are nested in a list column, hence it is also called the nested cubble. The rowwise structure makes it simpler to operate on the list using the \code{mutate()} syntax, which is simpler than the \code{purr::map()} when working with a list column. For example, calculating the number of rainy days can be done by:

```{r echo = TRUE}
cubble_nested |>
  mutate(rain_day = sum(ts$prcp != 0))
```


## Change focus by facing the time-variables

The nested form can be used for those operations where the output is only indexed by the spatial identifier (\code{key}), but becomes inadequate when outputs need both a spatial and a temporal identifier (\code{key} and \code{index}). The \pkg{cubble} class also provides a long form, which expands the \code{ts} column and temporarily "hides" the spatial variables. The function \code{face_temporal()} is used to switch from the nested cubble into the long one. The first row in Figure \ref{fig:face} illustrates this operation where the focus of the cube now changes from the site-variable face to the time-variable face. This code switches the cubble just created into its long form:

```{r echo = TRUE}
cubble_long <- cubble_nested |> face_temporal()
cubble_long
```

The first line in printed cubble now shows the cubble in its long form and the third line has been changed to display the name and type of spatial variables: \code{lat [dbl], long [dbl], elev [dbl], name [chr], wmo_id [dbl]}. Unlike the nested form, the long cubble is built from a \code{grouped_df} object where all the observations from the same sites form a group.

```{r face, echo = FALSE, fig.align="center", out.width = "100%", fig.cap = "An illustration of function \\code{face\\_temporal} and \\code{face\\_spatial} in cubble. In the first row, \\code{face\\_temporal} switches a cubble from the nested form into the long form and the focus has switched from the spatial aspect (the side face) to the temporal aspect (the front face). In the second row, \\code{face\\_spatial} switches a cubble back to the nested form from the long form and shifts focus back to the spatial aspect."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.008.png"))
```

## Change focus back to the site-variable face

Wrangling spatio-temporal data can be seen as an iterative process in the spatial and temporal dimensions. Switching the focus back to the site-variable face can be accomplished by the function \code{face_spatial()}, which is the inverse of \code{face_temporal()}. The second row of Figure \ref{fig:face} illustrates the function, which is used as follows:

```{r echo = TRUE}
cubble_back <- cubble_long |> face_spatial()
cubble_back
identical(cubble_nested, cubble_back)
```

## Unfold spatial variables into the long cubble {#unfold}

Sometimes, analysts may need to apply some variable transformation that involves both the spatial and temporal variables. An example of this is the transformation of temporal variables into the spatial dimension in glyph maps [@Wickham2012-yr]. (Glyph maps will be explained in Section \ref{st_transformation}.) This type of operation can be seen as flattening, or *unfolding*, the cube into a 2D data frame. Here the function \code{unfold()} moves the spatial variables \code{long} and \code{lat} into the long cubble:

```{r echo = TRUE}
cubble_unfold <- cubble_long |> unfold(long, lat)
cubble_unfold
```

This function should generally be used in the last step of the analysis since it is a temporary operation, meaning that these added spatial variables will disappear, if switched to the nested form and then switched back:

```{r echo = TRUE}
cubble_unfold |> face_spatial() |> face_temporal()
```

<!-- https://www.jstatsoft.org/style#my-latex-paper-does-not-compile-when-there-is-jss-markup-in-section-titles-what-should-i-do -->

## Why not just use the existing tidyverse functions {#tidyverse}

<!-- \subsection[Why not just use]{Why not just use \code{dplyr::nest\_by()}?} -->

Some readers may question why a new data structure is needed rather than directly creating a list-column  on the combined data using \code{dplyr::nest_by()}. The reason is that cubble is specifically designed to utilize the spatio-temporal structure when arranging variables from different observational units into a single object. Moreover, it enables easy pivoting between purely spatial, purely temporal, or unfolded into a combined form.

<!-- Some readers may raise the question why a new data structure rather than using \code{dplyr::nest_by()} on the combined data to directly create a list-column. While \code{nest_by()} and its inverse \code{unnest()} can mimic the nested form in cubble, cubble can be seen as an attempt to arrange variables from different observational units into a single object, specifically for spatio-temporal data. The benefit of arranging everything in a single object is that there is no need to manually split and join variables in the data. For various spatial, temporal, or spatio-temporal tasks, the data format required can alternate among a pure spatial, pure temporal, or a combined format. Analysts will need to manually split the combined data into a spatial or temporal one, or join them into a combined one. \pkg{Cubble} simplifies this switch of format with a nested and long form and allowing spatial variables to be unfolded into the long form for a combined data all in a single data object. -->

## Compatibility with existing packages {#compact}

This section will demonstrate how the \code{cubble} class interacts with existing packages commonly used in spatial and temporal analysis, specifically, \code{dplyr}, \code{tsibble}, \code{sf} (\code{s2}), and \code{netcdf4}.

### dplyr

The \code{dplyr} package has introduced many tools for data wrangling tasks and these operations are useful in the spatio-temporal context. \code{cubble} provides methods that support the following \code{dplyr} verbs in both the nested and long form:

 > `mutate`, `filter`, `summarise`, `select`, `arrange`, `rename`, `left_join`, and the slice family (`slice_head`, `slice_tail`, `slice_sample`, `slice_min`, `slice_max`)

### tsibble

\code{tsibble} is a temporal data structure that uses \code{index} and \code{key} to identify the time and different series. \code{cubble} can be seen as following the same vein as \code{tsibble} for spatio-temporal data. This makes it easy to cast a \code{tsibble} into a \code{cubble} as only the \code{coords} argument needs to be supplied:

```{r echo = TRUE}
# example with a tsibble created from climate_flat
raw <- climate_flat |> tsibble::as_tsibble(key = id, index = date)
dt <-  raw |> cubble::as_cubble(coords = c(long, lat))
dt
```

When a nested cubble is created, each element in the list-column \code{ts} is of \code{tbl_ts} class and operations available to the tsibble class are still valid within the cubble. For example, the code below calculates two time series features (mean and variance) of the maximum temperature variable:

```{r echo = TRUE}
# add station-based features in the nested form.
dt |> 
  mutate(
    fabletools::features(
      ts, tmax, list(tmax_mean = mean, tmax_var = var)
      )
  )
```

### sf and s2

As a spatial data object, \code{sf} creates a feature geometry list-column (\code{sfc}) in the data frame to provide spatial operations on various geometry types such as (\code{POINT}, \code{LINESTRING}, \code{POLYGON}, \code{MULTIPOLYGON}, etc). When creating a cubble a \code{sf} object can be supplied as the spatial table. Once that is included in a cubble, methods for the \code{sfc} class can be applied in the nested form inside the cubble object.  An example of this is shown in \@ref(covid), which also handles the case when the site identifiers in the two tables do not match exactly. A spatial data object with an \code{s2} vector can also be the input for the spatial table in \pkg{cubble}.


<!-- These spatial operations are also valuable for spatio-temporal data analysis, but an \code{sf} object *usually* does not contain temporal variables. This means \code{sf} cannot be directly cast into a \code{cubble}, however, \code{cubble} does support \code{sfc} columns in the nested form and spatial operations applied to the \code{sfc} column in \code{sf} can still be applied to the \code{sfc} column in a cubble. The following example shows how to create an \code{sfc} column of \code{POINT} type from latitude and longitude in cubble. Then \code{sf::st_within} is used to add the state \code{MULTIPOLYGON} of each weather station before a coordinate transformation is made. -->

<!-- ```{r echo = TRUE} -->
<!-- library(sf) -->
<!-- # create a cubble -->
<!-- cb <- climate_flat |> -->
<!--   cubble::as_cubble(key = id, index = date, coords = c(long, lat)) -->

<!-- aus <- ozmaps::abs_ste -->

<!-- dt <- cb |> -->
<!--   mutate( -->
<!--     # create `sfc` column based on long and lat -->
<!--     ll = st_sfc( -->
<!--       purrr::map2(long, lat, ~st_point(c(.x, .y))), -->
<!--       crs = st_crs(aus)), -->

<!--     # append state multi-polygon based on the `sfc` created -->
<!--     state = aus$geometry[st_within(ll, aus, sparse = FALSE)], -->

<!--     # adopt a different projection: lambert conformal conic (EPSG:3112) -->
<!--     state = st_transform(state, crs = "EPSG:3112") -->
<!--     ) -->

<!-- dt -->
<!-- ``` -->

<!-- An \pkg{s2} \code{lnglat} vector can similarly be created as an \code{sfc} in cubble before using any \code{s2}-prefixed function: -->

<!-- ```{r echo = TRUE} -->
<!-- library(s2) -->
<!-- # Western Australia map -->
<!-- wa <- ozmaps::abs_ste |> filter(NAME == "Western Australia") -->

<!-- # mutate a `s2_lnglat` vector on `cb` created in the last chunk -->
<!-- cb |> -->
<!--   mutate(ll = s2_lnglat(long, lat)) |> -->
<!--   filter(s2_within(ll, wa)) -->
<!-- ``` -->


### netcdf {#netcdf}

NetCDF data is another format that is commonly used for storing spatio-temporal data. It has two main components: *dimension* for defining the spatio-temporal grid (longitude, latitude, and time) and *variable* that populates the defined grid. Attributes are usually associated with dimensions and variables in the NetCDF format data and a [metadata convention for climate and forecast](http://cfconventions.org/) has been designed to standardise the format of the attributes. A few packages in R exist for manipulating NetCDF data and these include a high-level R interface: \pkg{ncdf4} [@ncdf4], a low-level interface that calls a C-interface: \pkg{RNetCDF} [@rnetcdf], and a tidyverse implementation: \pkg{tidync} [@tidync].

Cubble provides an \code{as_cubble()} method to coerce the \code{ncdf4} class from the \pkg{ncdf4} package into a \code{cubble}. It maps each combination of longitude and latitude into an \code{id} as the \code{key}:

```{r echo = TRUE, eval = FALSE}
# read in the .nc file as a ncdf4 class
raw <- ncdf4::nc_open(here::here("data/era5-pressure.nc"))

# convert the variable q and z in the ncdf4 into a cubble
dt <- as_cubble(raw, vars = c("q", "z"))
```

The memory limit with NetCDF data in cubble depends on the number of longitude grid points $\times$ the number of latitude grid points $\times$ the number of time grid points $\times$ the number of variables. Cubble can handle slightly more than 300 $\times$ 300 (longitude $\times$ longitude) grid points for three daily variables in one year. A 300 by 300 spatial grid can be a bounding box of [100, -80, 180, 0] at 0.25 degree resolution or a global bounding box [-180, -90, 180, -90] at 1 degree resolution. The spatial grid can also be subsetted to trade for longer time periods and more variables through \code{long_range} and \code{lat_range} if the NetCDF file has finer resolution than needed:

```{r eval = FALSE, echo = TRUE}
# Assume my_ncdf has a bounding box of [-180, -90, 180, -90]
# at 0.25 degree resolution and subset it to have
# 1 degree resolution:
dt <- as_cubble(my_ncdf, vars = c("q", "z"),
                long_range = seq(-180, 180, 1),
                lat_range = seq(-90, 90, 1))
```
