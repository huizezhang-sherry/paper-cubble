---
title: "2-the-cubble-pkg"
output: pdf_document
---

# The cubble package {#cubble}

This section will first introduce the core functions in the cubble class: \code{as_cubble()}, \code{face_spatial()}, \code{face_temporal()}, and \code{unfold()} in subsection \@ref(create) to \@ref(unfold). The next subsection addresses the necessity of creating a new class. Subsection \@ref(compact) will then show the compatibility of cubble with existing packages in spatial and temporal analysis.

Each core function is introduced accompanied with a short example and the data `climate_flat` is used throughout this section. `climate_flat` contains five weather stations in Australia with spatial information of each station: station id, latitude, longitude, elevation, station name, World Meteorology Organisation ID and also daily temporal information of date, maximum and minimum temperature and precipitation for 2020. The first five rows of `climate_flat` are shown below:

```{r}
cubble::climate_flat
```

## Create a cubble {#create}

Spatio-temporal data can come in various formats and shapes and a cubble can be created from various raw data. This includes tibble and its variates multiple tables (an example provided in section \@ref(covid)), and netCDF (detailed in section \@ref(netcdf)). The function \code{as_cubble()} is used to create a cubble with three additional components: \code{key} as the spatial identifier; \code{index} as the temporal identifier; and a vector of \code{coords} in the order of longitude and latitude. The arguments \code{key} and \code{index} follow the wording in \pkg{tsibble} to describe the temporal order and multiple series while \code{coords} is a space specific argument to locate each site in two columns. The code below creates a cubble out of \code{climate_flat} with \code{id} as the key, \code{date} as the index, and \code{c(long, lat)} as the coordinates:

```{r echo = TRUE}
cubble_nested <- climate_flat |>
  as_cubble(key = id, index = date, coords = c(long, lat))
cubble_nested
```

The cubble header provides some information about this data. \code{id} is the variable name to identify each location and there are five unique locations. The bounding box is \code{[115.97, -32.94, 133.55, -12.42]}. In the third row is the name and type of variable nested in the \code{ts} column and here it includes \code{date [date], prcp [dbl], tmax [dbl], tmin [dbl]}.

The created cubble is built from a \code{rowwise_df} class where each row forms a group. All the temporal variables are nested in a list column, hence it is also called the nested cubble. The rowwise structure makes it simpler to calculate on the list using the \code{mutate()} syntax, which is simpler than the {\code{map()} when working with list column. For example, calculating the number of raining days can be done by:

```{r echo = TRUE}
cubble_nested |>
  mutate(rain_day = sum(ts$prcp != 0))
```


## Change focus to the time-variable face

The nested form can be used for those operations whose output is only indexed by the spatial identifier (\code{key}), while for those outputs cross-identified by the spatial and temporal identifier (\code{key} and \code{index}), the nested form becomes inadequate. \pkg{cubble} also provides a long form, which expands the \code{ts} column and temporarily "hides" the spatial variables. The function \code{face_temporal()} is used to switch a nested cubble into a long one and the first row in Figure \ref{fig:face} illustrates this operation where the focus of the cube now changes from the site-variable face to the time-variable face. This code switches the cubble just created into its long form:

```{r echo = TRUE}
cubble_long <- cubble_nested |> face_temporal()
cubble_long
```

The first line in the header now shows the cubble is in its long form and the third line has been changed to show the name and type of spatial variables: \code{lat [dbl], long [dbl], elev [dbl], name [chr], wmo_id [dbl]}. Unlike the nested form, the long cubble is built from class \code{groupped_df} where all the observations from the same sites form a group.

```{r face, echo = FALSE, fig.align="center", out.width = "100%", fig.cap = "An illustration of function \\code{face\\_temporal} and \\code{face\\_spatial} in cubble. In the first row, \\code{face\\_temporal} switches a cubble from the nested form into the long form and the focus has switched from the spatial aspect (the side face) to the temporal aspect (the front face). In the second row, \\code{face\\_spatial} switches a cubble back to the nested form from the long form and shifts focus back to the spatial aspect."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.008.png"))
```

## Change focus back to the site-variable face

Wrangling spatio-temporal data can be an iterative process in the spatial and temporal dimensions. Switching the focus back to the site-variable face can be accomplished by the function \code{face_spatial()}, which is the inverse of \code{face_temporal()}. The second row of Figure \ref{fig:face} illustrates the function and below is an example on the climate data:

```{r echo = TRUE}
cubble_back <- cubble_long |> face_spatial()
cubble_back
identical(cubble_nested, cubble_back)
```

## Flatten spatial variables into the long cubble {#unfold}

Sometimes, analysts may need to apply some variable transformation that involves both the spatial and temporal variables. An example of this is the transformation of temporal variables into the spatial dimension in glyph maps, which will be elaborated in section \ref{st_transformation}. This type of operation can be seen as flattening, or *unfolding*, the cube into a 2D data frame. Here the function \code{unfold()} moves the spatial variables \code{long} and \code{lat} into the long cubble:

```{r echo = TRUE}
cubble_unfold <- cubble_long |> unfold(long, lat)
cubble_unfold
```

This function should generally be used in the last step of the analysis since it is a temporary operation, meaning these added spatial variables will disappear if switched to the nested form and then switched back:

```{r echo = TRUE}
cubble_unfold |> face_spatial() |> face_temporal()
```

<!-- https://www.jstatsoft.org/style#my-latex-paper-does-not-compile-when-there-is-jss-markup-in-section-titles-what-should-i-do -->
\subsection[Why not just use]{Why not just use \code{dplyr::nest\_by()}?}

Some readers may raise the question why a new data structure rather than using \code{dplyr::nest_by()} on the combined data to directly create a list-column. While \code{nest_by()} and its pair \code{unnest()} can mimic the nested form in cubble, cubble can be seen as an attempt to arrange variables from different observational units into a single object, specifically for spatio-temporal data. While `nest_by()` can recreate the nested form, it cannot create a clean slate for temporal variables as the long form. For temporal variables, carrying the duplicated spatial variables in the combined form is not convenient to work with. This is because these spatial variables will be lost after \code{summarise()} and one will need to subset the spatial variables again from the original data and make a left join, which tends to create unnecessary intermediate products in the workflow.

```{r eval = FALSE, echo = TRUE}
# operation on the long form w/o cubble
# cubble workflow
dt |>
  as_cubble(...) |>
  face_temporal() |>
  group_by() |>
  summarise() |>
  unfold(...)

# tidyverse workflow
temporal <- dt |>
  group_by(...) |>
  summarise(...)

spatial <- dt |> select(....)

spatial |> left_join(temporal)
```

<!-- ```{r} -->
<!-- library(dplyr) -->
<!-- vars <- c(id, lat, long, elev, name, wmo_id) -->
<!-- left_join(cubble::stations, cubble::climate) |>  -->
<!--   group_by(id, lat, long, elev, name, wmo_id) |>  -->
<!--   summarise(tmax_mean = mean(tmax)) -->

<!-- cubble::climate |>  -->
<!--   mutate(month = lubridate::month(date)) |>  -->
<!--   group_by(id, month) |>  -->
<!--   summarise(tmax_mean = mean(tmax)) |>  -->
<!--   ungroup() |>  -->
<!--   left_join(cubble::stations) |>  -->
<!--   nest_by(id, lat, long, elev, name, wmo_id) -->


<!-- ``` --

<!-- ``` r -->
<!-- library(cubble) -->
<!-- library(tidyverse) -->
<!-- left_join(cubble::stations, cubble::climate) |> -->
<!--   dplyr::nest_by(id, lat,  long,  elev, name, wmo_id) |> -->
<!--   tidyr::unnest() |> -->
<!--   group_by(........, geometry) -->
<!-- ``` -->

## Compatibility with existing packages {#compact}

The previous four subsections have introduced operations specific to the \code{cubble} class and this section will demonstrate how the \code{cubble} class interacts with existing packages commonly used in spatial and temporal analysis, specifically, \code{dplyr}, \code{tsibble}, \code{sf} (\code{s2}), and \code{netcdf4}.

### dplyr

The \code{dplyr} package has provided many tools for data wrangling tasks and these operations are useful in the spatio-temporal context. \code{cubble} provides methods that support the following \code{dplyr} verbs in both the nested and long form:

 > `mutate`, `filter`, `summarise`, `select`, `arrange`, `rename`, `left_join`, and the slice family (`slice_head`, `slice_tail`, `slice_sample`, `slice_min`, `slice_max`)

### tsibble

\code{tsibble} is a temporal data structure that uses \code{index} and \code{key} to identify the time and different series. \code{cubble} can be seen as following the same vein as \code{tsibble} for spatio-temporal data. This makes it easy to cast a \code{tsibble} into a \code{cubble} as only the \code{coords} argument needs to be supplied:

```{r echo = TRUE}
# example with a tsibble created from climate_flat
raw <- climate_flat |> tsibble::as_tsibble(key = id, index = date)
dt <-  raw |> cubble::as_cubble(coords = c(long, lat))
dt
```

In the nested cubble created, each element in the list-column \code{ts} is of \code{tbl_ts} class and operations available to the tsibble class is still valid under cubble. For example, the code below calculates two features of the maximum temperature:

```{r echo = TRUE}
# add station-based features in the nested form.
dt |> mutate(fabletools::features(ts, tmax, list(tmax_mean = mean, tmax_var = var)))
```

### sf and s2

As a spatial data object, \code{sf} creates a simple feature geometry list-column (\code{sfc}) in the data frame to provide spatial operations on various geometry types (\code{POINT}, \code{LINESTRING}, \code{POLYGON}, \code{MULTIPOLYGON}, etc). An \code{sf} object can be supplied as the spatial table, as part of the raw data, along with a temporal table, to create a cubble. Once formed in a cubble, methods for the \code{sfc} class can be applied in the nested form.  An example of this is shown in \@ref(covid), which also handles the case when the sites in the two tables do not match exactly. A spatial data object with \code{s2} vector can also be the input of the spatial table.


<!-- These spatial operations are also valuable for spatio-temporal data analysis, but an \code{sf} object *usually* does not contain temporal variables. This means \code{sf} cannot be directly cast into a \code{cubble}, however, \code{cubble} does support \code{sfc} columns in the nested form and spatial operations applied to the \code{sfc} column in \code{sf} can still be applied to the \code{sfc} column in a cubble. The following example shows how to create an \code{sfc} column of \code{POINT} type from latitude and longitude in cubble. Then \code{sf::st_within} is used to add the state \code{MULTIPOLYGON} of each weather station before a coordinate transformation is made. -->

<!-- ```{r echo = TRUE} -->
<!-- library(sf) -->
<!-- # create a cubble -->
<!-- cb <- climate_flat |> -->
<!--   cubble::as_cubble(key = id, index = date, coords = c(long, lat)) -->

<!-- aus <- ozmaps::abs_ste -->

<!-- dt <- cb |> -->
<!--   mutate( -->
<!--     # create `sfc` column based on long and lat -->
<!--     ll = st_sfc( -->
<!--       purrr::map2(long, lat, ~st_point(c(.x, .y))), -->
<!--       crs = st_crs(aus)), -->

<!--     # append state multi-polygon based on the `sfc` created -->
<!--     state = aus$geometry[st_within(ll, aus, sparse = FALSE)], -->

<!--     # adopt a different projection: lambert conformal conic (EPSG:3112) -->
<!--     state = st_transform(state, crs = "EPSG:3112") -->
<!--     ) -->

<!-- dt -->
<!-- ``` -->

<!-- An \pkg{s2} \code{lnglat} vector can similarly be created as an \code{sfc} in cubble before using any \code{s2}-prefixed function: -->

<!-- ```{r echo = TRUE} -->
<!-- library(s2) -->
<!-- # Western Australia map -->
<!-- wa <- ozmaps::abs_ste |> filter(NAME == "Western Australia") -->

<!-- # mutate a `s2_lnglat` vector on `cb` created in the last chunk -->
<!-- cb |> -->
<!--   mutate(ll = s2_lnglat(long, lat)) |> -->
<!--   filter(s2_within(ll, wa)) -->
<!-- ``` -->


### netcdf {#netcdf}

NetCDF data is another format that is commonly used for storing spatio-temporal data. It has two main components: *dimension* for defining the spatio-temporal grid (longitude, latitude, and time) and *variable* that populates the defined grid. Attributes are usually associated with dimensions and variables in the NetCDF format data and a [metadata convention for climate and forecast](http://cfconventions.org/) has been designed to standardise the format of the attributes. A few packages in R exist for manipulating NetCDF data and these include a high-level R interface: \pkg{ncdf4} [@ncdf4], a low-level interface that calls a C-interface: \pkg{RNetCDF} [@rnetcdf; @michna2013rnetcdf], and a tidyverse implementation: \pkg{tidync} [@tidync].

Cubble provides an \code{as_cubble()} method to coerce the \code{ncdf4} class from the \pkg{ncdf4} package into a \code{cubble}. It maps each combination of longitude and latitude into an \code{id} as the \code{key}:

```{r echo = TRUE, eval = FALSE}
# read in the .nc file as a ncdf4 class
raw <- ncdf4::nc_open(here::here("data/era5-pressure.nc"))

# convert the variable q and z in the ncdf4 into a cubble
dt <- as_cubble(raw, vars = c("q", "z"))
```

The memory limit with NetCDF data in cubble depends on the number of longitude grid points $\times$ the number of latitude grid points $\times$ the number of time grid points $\times$ the number of variables. Cubble can handle slightly more than 300 $\times$ 300 (longitude $\times$ longitude) grid points for three daily variables in one year. A 300 by 300 spatial grid can be a bounding box of [100, -80, 180, 0] at 0.25 degree resolution or a global bounding box [-180, -90, 180, -90] at 1 degree resolution. The spatial grid can also be subsetted to trade for longer time periods and more variables through \code{long_range} and \code{lat_range} if the NetCDF file has finer resolution than needed:

```{r eval = FALSE, echo = TRUE}
# Assume my_ncdf has a bounding box of [-180, -90, 180, -90]
# at 0.25 degree resolution and subset it to have
# 1 degree resolution:
dt <- as_cubble(my_ncdf, vars = c("q", "z"),
                long_range = seq(-180, 180, 1),
                lat_range = seq(-90, 90, 1))
```
