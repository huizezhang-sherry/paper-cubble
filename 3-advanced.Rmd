---
title: "3-advanced"
output: pdf_document
---

# Other features and considerations {#others}

## Data fusion and matching {#matching}

One task that may interest spatio-temporal analysts is combining data collected at nearby but not exactly the same sites, for example, weather station measured rainfall and river levels. This can be considered to be a matching problem [@stuart2010matching; @mcintosh2018using] to pair similar time series from nearby locations, or even a data fusion exercise that merges data collected from different sources [@cocchi2019data]. The function \code{match_sites()} in the \pkg{cubble} package provides a simple algorithm for this task. 

Spatial matching based on distance.

````
match_spatial(df1, df2, ...)
````

Allow one-to-many output, control the number of group and number of match within each group with arguments: 

Temporal matching, apply on spatially matched group

````
match_temporal(<SPATIAL_RES>, group_id, match_id, temporal_by = c("xxx" = "xxx"))
````

Different matching functions can be tuned with `temporal_match_fn`, which takes a list of matched time series and additional arguments. By Default, the matching function calculates the number of peaks one series falls into another within a temporal window: `match_peak`

<!-- The algorithm first matches spatially by computing the pairwise distance on latitude and longitude. Then it matches temporally by computing the number of matched peaks within a fixed length moving window. Figure \ref{fig:illu-matching} illustrates this temporal matching. In the two series, *A* and *a*, three peaks have been identified in each. An interval, of fixed length, is constructed for each peak in series *A*, while the peaks in series *a* are tested against whether they fall into any of the intervals. Here two out of three peaks match. Options for \code{match_sites()} are: -->

## Interactive graphics

The workflow with the \code{cubble} class works well with an interactive graphics pipeline (e.g., @buja1988elements; @buja1996interactive;  @sutherland2000orca; @xie2014reactive; @cheng2016enabling) that is available in \proglang{R} with the package \pkg{crosstalk} [@crosstalk]. Figure \ref{fig:illu-interactive} illustrates how linking can be achieved between a map and multiple time series in a \code{cubble} object. The map (produced from the nested form) and time series (produced from the long form) are both shared \code{crosstalk} objects. When a user makes a selection on the map, the site is highlighted (a). This activates a row in the nested \code{cubble}, which is then communicated to the long \code{cubble} -- all the observations with the same id (b) will be selected. The long \code{cubble} will then highlight the corresponding series in the time series plot (c).

Linking is also available starting from the time series plot, by selecting points. This will activate rows having the same id in the long \code{cubble}. The corresponding rows in the nested \code{cubble} are activated, and highlighted on the map. (An illustration can be found in the appendix.) Note that this type of linking, both from the map or the time series, is what @CS07 would call categorical variable linking, where station id is the categorical variable. 

```{r illu-interactive, echo = FALSE, fig.align="center", out.height = "35%", out.width = "100%", fig.cap = "Linking between multiple plots. The line plots and the map are constructed from shared \\code{crosstalk} objects (long and nested \\code{cubble}). When a station is selected on the map (a), the corresponding row in the nested \\code{cubble} will be activated. This will link to all the rows with the same id in the long \\code{cubble} (b) and update the line plot (c)."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.002.png"))
```

## Spatio-temporal transformations {#st_transformation}

Spatio-temporal data lends itself to a range of transformations. Glyph maps [@Wickham2012-yr] transform the measured variable and time coordinates into microplots at the spatial locations. Calendar plots [@wang2020calendar] deconstruct time to produce plots of variables in a calendar format. Summarizing multiple variables is commonly done using projections, or linear combinations. Here we elaborate on the transformations made to produce a glyph map. The package \pkg{GGally} [@ggally] has implemented glyph maps through the \code{glyphs()} function. The function constructs a \code{data.frame} with calculated position (\code{gx}, \code{gy}, \code{gid}) of each point on the time series using linear algebra (Equations 1 and 2 in @Wickham2012-yr). A new implementation of the glyph map as a ggproto, \code{GeomGlyph}, has been made in the \pkg{cubble} package so that a glyph map can be created with \code{geom_glyph()}:

```{r eval = FALSE, echo = TRUE}
data |>
  ggplot() +
  geom_glyph(aes(x_major = ..., x_minor = ...,
                 y_major = ..., y_minor = ...))
```

Some useful controls over the glyph map are also available in the \code{geom_glyph()} implementation
  
  * polar coordinate glyph maps are specified using \code{polar = TRUE}, 
  * arguments \code{width} and \code{height} can be specified in either absolute or relative value, 
  * global and local scale is specified with \code{global_rescale}, which defaults to \code{TRUE}, and 
  *reference boxes and lines can be added with geoms: \code{geom_glyph_box()} and \code{geom_glyph_line()}.
  