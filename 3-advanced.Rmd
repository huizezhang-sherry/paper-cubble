---
title: "3-advanced"
output: pdf_document
---

# Other features and considerations {#others}

## Data fusion and matching {#matching}

One task that may interest spatio-temporal analysts is combining data collected at nearby but not exactly the same sites, for example, weather station measured rainfall and river levels. This can be considered to be a matching problem [@stuart2010matching; @mcintosh2018using] to pair similar time series from nearby locations, or even a data fusion exercise that merges data collected from different sources [@cocchi2019data]. 


In cubble, data can be matched spatially or temporarily with `match_spatial()` and `match_temporal()`. The function `match_spatial()` calculates the spatial distance between observations in two cubbles. Different distances are available with projected or unprojected coordinate reference system. Analysts can subset the number of matched group to output with argument `spatial_n_group` (by default 4 groups) and the number of match per group with argument `spatial_n_group` (by default 1, that is, one-to-one matching). The syntax to use `match_spatial()` is:
  
````
match_spatial(<cubble_obj1>, <cubble_obj2>, ...)
````

The function `match_temporal()` calculates the time series similarity between spatially matched groups. Two identifiers needs to be specified on the variable separates the each matched group (`match_id`) and the variable separates the two sources (`data_id`). The argument `temporal_by` uses the `by` syntax from dplyr `*_join` to specify the temporal matching variable. 
  
  The similarity score between two time series in the spatially matched group is calculated by a matching function, which analysts can customise. The matching function should take two time series in a list and output a single numerical score, which allows for interfacing with existing time series distance calculation implementation. By default, cubble implements a simple peak matching algorithm (`match_peak`) that counts the number of peaks in two time series that fall within a specified temporal window. The syntax to use `match_temporal()` is:
  
````
match_temporal(
  <cubble_obj_from_match_spatial>, 
  data_id = ... , match_id = ..., 
  temporal_by = c("..." = "...")
)
````

## Interactive graphics

The workflow with the \code{cubble} class works well with an interactive graphics pipeline (e.g., @buja1988elements; @buja1996interactive;  @sutherland2000orca; @xie2014reactive; @cheng2016enabling) that is available in \proglang{R} with the package \pkg{crosstalk} [@crosstalk]. Figure \ref{fig:illu-interactive} illustrates how linking can be achieved between a map and multiple time series in a \code{cubble} object. The map (produced from the nested form) and time series (produced from the long form) are both shared \code{crosstalk} objects. When a user makes a selection on the map, the site is highlighted (a). This activates a row in the nested \code{cubble}, which is then communicated to the long \code{cubble} -- all the observations with the same id (b) will be selected. The long \code{cubble} will then highlight the corresponding series in the time series plot (c).

Linking is also available starting from the time series plot, by selecting points. This will activate rows having the same id in the long \code{cubble}. The corresponding rows in the nested \code{cubble} are activated, and highlighted on the map. (An illustration can be found in the appendix.) Note that this type of linking, both from the map or the time series, is what @CS07 would call categorical variable linking, where station id is the categorical variable. 

```{r illu-interactive, echo = FALSE, fig.align="center", out.height = "35%", out.width = "100%", fig.cap = "Linking between multiple plots. The line plots and the map are constructed from shared \\code{crosstalk} objects (long and nested \\code{cubble}). When a station is selected on the map (a), the corresponding row in the nested \\code{cubble} will be activated. This will link to all the rows with the same id in the long \\code{cubble} (b) and update the line plot (c)."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.002.png"))
```

## Spatio-temporal transformations {#st_transformation}

Spatio-temporal data lends itself to a range of transformations. Glyph maps [@Wickham2012-yr] transform the measured variable and time coordinates into microplots at the spatial locations. Calendar plots [@wang2020calendar] deconstruct time to produce plots of variables in a calendar format. Summarizing multiple variables is commonly done using projections, or linear combinations. Here we elaborate on the transformations made to produce a glyph map. The package \pkg{GGally} [@ggally] has implemented glyph maps through the \code{glyphs()} function. The function constructs a \code{data.frame} with calculated position (\code{gx}, \code{gy}, \code{gid}) of each point on the time series using linear algebra (Equations 1 and 2 in @Wickham2012-yr). A new implementation of the glyph map as a ggproto, \code{GeomGlyph}, has been made in the \pkg{cubble} package so that a glyph map can be created with \code{geom_glyph()}:

```{r eval = FALSE, echo = TRUE}
data |>
  ggplot() +
  geom_glyph(aes(x_major = ..., x_minor = ...,
                 y_major = ..., y_minor = ...))
```

Some useful controls over the glyph map are also available in the \code{geom_glyph()} implementation
  
  * polar coordinate glyph maps are specified using \code{polar = TRUE}, 
  * arguments \code{width} and \code{height} can be specified in either absolute or relative value, 
  * global and local scale is specified with \code{global_rescale}, which defaults to \code{TRUE}, and 
  *reference boxes and lines can be added with geoms: \code{geom_glyph_box()} and \code{geom_glyph_line()}.
  