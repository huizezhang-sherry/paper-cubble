---
documentclass: jss
author:
  - name: H. Sherry Zhang
    affiliation: Monash University
    address: 21 Chancellors Walk, Clayton VIC 3800 Australia
    email: \email{huize.zhang@monash.edu}
  - name: Dianne Cook
    affiliation: Monash University
    address: 21 Chancellors Walk, Clayton VIC 3800 Australia
    email: dicook@monash.edu
  - name: Ursula Laa
    affiliation: 'University of  Natural `\\`{=latex} Resources and Life Sciences \AND'
    address: Gregor-Mendel-Straße 33, 1180 Wien, Austria
    email:  ursula.laa@boku.ac.at
  - name: Nicolas Langrené
    affiliation: 'BNU-HKBU `\\`{=latex} United International College'
    address: 2000 Jintong Road, Tangjiawan, Zhuhai, Guangdong Province, China
    email: nicolaslangrene@uic.edu.cn
  - name: Patricia Menéndez
    affiliation: Monash University
    address: 21 Chancellors Walk, Clayton VIC 3800 Australia
    email:  patricia.menendez@monash.edu
title:
  formatted: "\\pkg{cubble}: An \\proglang{R} Package for Organizing and Wrangling Multivariate Spatio-temporal Data"
  # If you use tex in the formatted title, alsoge supply version without
  plain:     "cubble: An R Package for Organizing and Wrangling Multivariate Spatio-temporal Data"
  # For running headers, if needed
  # short:     "\\pkg{foo}: A Capitalized Title"
abstract: >
     Multivariate spatio-temporal data refers to multiple measurements taken across space and time. For many analyses, spatial and time components can be separately studied: for example, to explore the temporal trend of one variable for a single spatial location, or to model the spatial distribution of one variable at a given time. However for some studies, it is important to analyze different aspects of the spatio-temporal data simultaneously, like for instance, temporal trends of multiple variables across locations. In order to facilitate the study of different portions or combinations of spatio-temporal data, we introduce a new class, \code{cubble}, with a suite of functions enabling easy slicing and dicing on different spatio-temporal components.  The proposed \code{cubble} class ensures that all the components of the data are easy to access and manipulate while providing flexibility for data analysis. In addition, the \pkg{cubble} package facilitates visual and numerical explorations of the data while easing data wrangling and modelling. The \code{cubble} class and the functions provided in the \pkg{cubble} \proglang{R} package equip users with the capability to handle hierarchical spatial and temporal structures. The \code{cubble} class and the tools implemented in the package are illustrated with different examples of Australian climate data.
keywords:
  # at least one keyword must be supplied
  formatted: [spatial, temporal, spatio temporal, "\\proglang{R}", environmental data, exploratory data analysis]
  plain:     [spatial, temporal, spatio temporal, R, environmental data, exploratory data analysis]
preamble: >
  \usepackage{amsmath}
  \usepackage{array}
output: 
  bookdown::pdf_book:
    base_format: rticles::jss_article
bibliography: references.bib
---
<!-- Universität für Bodenkultur Wiens \AND -->
```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  cache = TRUE,
  fig.path = here::here("figures/")
)

options(prompt = "R> ", continue = "+ ",
        tibble.print_max = 5, tibble.print_min = 5,
        width = 80, styler.cache_root = "styler-perm")
```

```{r echo = FALSE}
library(cubble)
library(tidyverse)
library(patchwork)
library(tsibble)
library(sf)
```

# Introduction

Spatio-temporal data has a spatial component referring to the location of each observation and a temporal component that is recorded at regular or irregular time intervals. It may also include multiple variables measured at each spatial and temporal values. With spatio-temporal data, one can fix the time to explore the spatial features of the data, fix the spatial location/s to explore temporal aspects, or dynamically explore the space and time simultaneously. 

In order to computationally explore the spatial, temporal and spatio-temporal faces of such data, the data needs to be stored and represented under a specific data object that allows the user to query, group and dissect all the data faces.

The Comprehensive \proglang{R} Archive Network (CRAN) task view SpatioTemporal [@ctvspatiotemporal] gathers information about \proglang{R} packages designed for spatio-temporal data and it has a section on *Representing data* that lists existing spatio-temporal data representations used in \proglang{R}. Among them, @spacetime summarises spatio-temporal data into three forms: time-wide, space-wide, and long formats. The associated package \pkg{spacetime} [@spacetime] implements four spatio-temporal layouts (full grid, sparse grid, irregular, and trajectory) to handle different space and time combinations. The package \pkg{stars} [@stars] has a new implementation to use dense arrays to represent spatio-temporal cubes. It also interfaces with the package \pkg{sf} [@sf], commonly used for wrangling spatial data, and the \pkg{tidyverse} [@tidyverse] suite for general data wrangling and visualization in \proglang{R}.

Still, the data representation for spatio-temporal data can be further extended and there are two reasons for this. Firstly, the raw data sourced in the wild is less often presented in any one of the layouts above, and fitting the raw data into a data object can sometimes be difficult. More often, spatio-temporal data are collected in separate 2D tables and analysts need to assemble them into a whole piece before exploring the data. Examples of components of spatio-temporal data can be 1) areal data recording the shape of a collection of areas of interest; 2) geostatistical data storing the longitude and latitude coordinates of locations, typically also with other metadata related to the location, and; 3) temporal data of each location across time.

The other reason is about tidy data concepts [@tidydata] and how they should be applied to spatio-temporal data. According to the tidy data principles, data should be structured into 1) one row per observation, 2) one column per variable, and 3) one type of data per table. The long form data is preferred over wide data form given the downstream packages such as \pkg{dplyr} [@dplyr] and \pkg{ggplot2} [@ggplot2] for data wrangling and visualization. However, the long form can be inefficient to store feature geometries, especially for large multipolygons for hourly, daily or sub-daily periods over years, which are extensively collected and handled, for example in time series analysis. This poses the question of how to arrange spatial and temporal variables in a way that would make data wrangling, visualizing and analyzing spatio-temporal data easier.

This paper presents a new \proglang{R} package, \pkg{cubble}, which addresses the two issues mentioned above. In the package, a new class, also called cubble, is proposed to organize spatial and temporal variables as two forms of a single data object so that they can be wrangled separately or combined while being kept synchronized. Among the four spacetime layouts in @spacetime, the \code{cubble} class can be applied to full grid, sparse grid, or irregular, but not trajectory, which is outside the scope of this work. The software is available from the Comprehensive \proglang{R} Archive Network (CRAN) at https://CRAN.R-project.org/package=cubble. 

The rest of the paper is organized as follows: Section \@ref(cubble) presents the main design and functionality of the \pkg{cubble} package. Section \@ref(others) explains how the \pkg{cubble} package deals with more advanced considerations, including data with hierarchical structure, data matching and how the package fits with existing static and interactive visualization tools. Moreover we also illustrate how the \pkg{cubble} package deals with spatio-temporal data transformations. Section \@ref(examples) uses Australian weather station data and river level data as examples to demonstrate the use of the package. An example of how the \pkg{cubble} package handles Network Common Data Form (NetCDF) data is also provided. Section \@ref(conclude) discuss the paper contributions and future directions.

# The cubble package {#cubble}

## The cubble object {#object}

Spatio-temporal data can encompass data with various spatial and temporal characteristics and different data require different structures for wrangling and analysis: climate weather stations record data at fixed point location but may suffer from potential temporal data quality issue such as missing data for certain days. GPS data tracks unique point locations at different timestamps and is represented as trajectories. Satellite imageries capture snapshots of landscapes at selected time and is commonly structured as raster data. The spatio-temporal data cubble address are those collected at unique fixed locations while allowing for irregularity in the temporal dimension, such as the weather station data. This corresponds to the full space-time and sparse space-time layouts described in the spacetime paper [@spacetime] and reproduced in Figure  \ref{fig:layout}.

```{r layout, echo = FALSE, fig.cap="The full space-time and sparse space-time layouts handled by the cubble package. Reproduced from Figure 1 in the spacetime paper \\citep{spacetime}.", fig.width = 8, fig.height=4, fig.align='center'}
library(tidyverse)
library(patchwork)
p1 <- tibble(
  id = 1:12,
  x = rep(1:4, each = 3),
  y = rep(1:3, 4)
) %>% 
  ggplot(aes(x = as.factor(x) ,y = as.factor(y))) + 
  geom_point() + 
  geom_text(aes(y = y - 0.2, label = id)) + 
  theme_bw() + 
  theme(aspect.ratio = 1) + 
  scale_x_discrete(labels = c("1st", "2nd", "3rd", "4th")) + 
  scale_y_discrete(labels = c("1st", "2nd", "3rd", "4th")) + 
  labs(x = "Time points", y = "Spatial features", title = "STF: full grid layout") 

p2 <- tibble(
  id = 1:7,
  x = c(1, 1, 1, 2, 2, 3, 4),
  y = c(1, 2, 3, 2, 3, 1, 2),
  label = c("1[1,1]", "2[1,2]", "3[1,3]", "4[2,2]", "5[3,2]", "6[1,3]", "7[2,4]")
) %>% 
  ggplot(aes(x = as.factor(x) ,y = as.factor(y))) + 
  geom_point() + 
  geom_text(aes(y = y - 0.2, label = label)) + 
  theme_bw() + 
  theme(aspect.ratio = 1) + 
  scale_x_discrete(labels = c("1st", "2nd", "3rd", "4th")) + 
  scale_y_discrete(labels = c("1st", "2nd", "3rd", "4th")) + 
  labs(x = "Time points", y = "Spatial features", title = "STS: sparse grid layout") 

p1 | p2
```

The cubble class is an S3 class built on tibble that allows the spatio-temporal data to be wrangled in two forms:  a nested form (spatial cubble) and a long form (temporal cubble). It consists of two subclasses:

-   a spatial cubble with class `c("spatial_cubble_df", "cubble_df")`
-   a emporal cubble with class `c("temporal_cubble_df", "cubble_df")`

In a spatial cubble, spaital variables are organised as columns and temporal variables are nested within a specialised `ts` column. The cubble object printed below contains weather records in three airport stations (the creation of a cubble object will be explained in Section \@ref(create)). This toy data is a subset of a larger data \code{climate_aus} collected from Global Historical Climatology Network Daily (GHCND). It records three airport stations located in Melbourne, Australia and includes spatial variables such as station ID, longitude, latitude, elevation, station name, World Meteorology Organisation ID. The dataset contains temporal variables including precipitation, maximum and minimum temperature, which can be read from the cubble header:

```{r}
cb_nested <- climate_mel
```

```{r echo = TRUE}
cb_nested
```

<!-- A nested cubble header prints the key and index variable name and its form. The spatial extent is given by the bounding box with CRS information (missing here). The nested cubble header also shows the name of temporal variables nested in the \code{ts} column and their variable types: \code{prcp [dbl], tmax [dbl], tmin [dbl]}. -->

In a temporal cubble, temporal variables are expanded in the long form and spatial variables are stored as a data attribute:

```{r}
cb_long <- face_temporal(climate_mel)
```

```{r echo = TRUE}
cb_long
```

### The cubble attributes

```{r class, fig.align="center", out.width = "100%", fig.cap = "Illustration of a cubble object in the long form and nested form, along with the associated attributes."}
#knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.004.png"))
```

A cubble object inherits the attributes from tibble (and its subclasses): `class`, `row.names`, and `names`. Additionally, it has three specialised attributes: `key`, `index`, and `coords`. Readers who are familiar with the `key` and `index` attributes from the `tsibble` package would already understand the two arguments. In cubble, the `key` attribute identifies the row in the spatial cubble (given the use of `tidyr::nest()` for nesting), and when combined with the `index` argument, it identifies the row in the temporal cubble. Currently, cubble only supports one variable as the key, and the accepted temporal classes for index includes the base R classes `Date`, `POSIXlt`, `POSIXct`, as well as tsibble's `yearmonth`, `yearweek`, and `yearquarter` classes.

The `coords` attribute represents an ordered pair of coordinates. It can be either an unprojected pair of longitude and latitude, or a projected easting and northing value. The `sf` package is used under the hood to calculate the bounding box, displayed in the header of a spatial cubble.

The temporal cubble has a special attribute called `spatial` to store the spatial variables. Shortcut functions are available to extract attributes, for example, \code{spatial()} for extracting spatial variables from the temporal cubble: 

```{r echo = TRUE}
spatial(cb_long)
```

## Creation and coercion {#create}

In many cases, spatio-temporal data arrive in separate tables for analysis. For example, in climate data, analysts may initially receive station data containing geographic location information, recorded variables and their recording periods. They can then query the temporal variables using the stations of interest to obtain the relevant temporal data. Alternatively, analyses may begin as purely spatial or temporal, and analysts may obtain additional temporal or spatial data to expand the result to spatio-temporal.

The function \code{make_cubble()} composes a \code{cubble} object from a spatial table (\code{spatial}) and a temporal table (\code{temporal}), along with three attributes introduced in the subsection \@ref(object): \code{key}, \code{index}, and \code{coords}. The following code creates the spatial \code{cubble} object shown previously:

```{r echo = TRUE, eval = FALSE}
make_cubble(spatial = stations, temporal = meteo,
            key = id, index = date, coords = c(long, lat))
```

Spatio-temporal data in other foreign objects can be coerced into a \code{cubble} object with the function \code{as_cubble()}. This includes casting from a \code{tibble} or \code{data.frame} with both spatial and temporal information, a NetCDF object, a \code{stars} object [@stars], and a \code{sftime} object [@sftime]. The two examples below show the casting from a tibble and a NetCDF object. The dataset \code{climate_flat} combines the spatial data, \code{stations}, with the temporal data, \code{meteo}, into a single tibble object. It can be coerced into a cubble using:

```{r echo = TRUE}
climate_flat |> as_cubble(key = id, index = date, coords = c(long, lat))
```

## Functions and methods

Table \@ref(tab:funs) summarises the functions implemented in the \pkg{cubble} package and Table \@ref(tab:methods) details the methods implemented for each of the three cubble classes. The \code{cubble_df} class handles methods that behave consistently in both spatial (\code{spatial_cubble_df}) and temporal cubble (\code{temporal_cubble_df}). When the method has distinct behavior for the spatial cubble and temporal cubble, it is implemented separately for each subclass.

| Category  | Functions |
|--------|--------------------------------------------------------|
| base R    | `[`, `[[<-`, `names<-` |
| tidyverse | `dplyr_row_slice`, `dplyr_col_modify`, `dplyr_reconstruct`, `select`, `mutate`, `arrange`, `filter`, `group_by`, `ungroup`, `summarise`, `select`, `slice`, `rowwise`, `rename`, `bind_rows`, `bind_cols`, `relocate`, `type_sum`, the slice family (`slice_head`, `slice_tail`, `slice_max`, `slice_min`, `slice_sample`) and the join family (`left_join`, `right_join`, `inner_join`, `full_join`, `anti_join`, `semi_join`) |
| cubble    | `as_cubble`, `cubble`, `make_cubble`, `check_key` `face_temporal`, `face_spatial`, `unfold`, `key`, `key_vars`, `key_data`, `index`, `index_var`, `coords`, `spatial`, `match_sites`, `match_spatial`, `match_temporal`, `geom_glyph`, `geom_glyph_box`, `geom_glyph_line`, `make_spatial_sf`, `make_temporal_tsibble`, `fill_gaps`, and `scan_gaps`                                                                                |

: (#tab:funs) Functions implemented in the \pkg{cubble} package

| Class                | Methods|
|------------------|------------------------------------------------------|
| `cubble_df`          | `[[<-, dplyr_col_modify, key_data, key_vars, key, print`                                                                                                                                                                                     |
| `spatial_cubble_df`  | `[, names<-,  tbl_sum, dplyr_reconstruct, dplyr_row_slice, face_spatial, face_temporal, unfold, arrange, rename, rowwise, group_by, ungroup, select, spatial, summarise, unfold, update_cubble`                                              |
| `temporal_cubble_df` | `[, names<-, tbl_sum, arrange, dplyr_reconstruct, dplyr_row_slice, face_spatial, face_temporal, unfold, fill_gaps, group_by, ungroup,  rename, rowwise, scan_gaps, select, spatial, summarise, tbl_sum, bind_rows, bind_cols, update_cubble` |

: (#tab:methods) Methods implemented for the three \code{cubble} classes.

Specifically, the pair of verbs, \code{face_temporal()} and \code{face_spatial()}, pivot the cubble object between the spatial and temporal face of the multivariate spatio-temporal cube, as illustrated in Figure \ref{fig:face}. The code below uses the function \code{face_temporal()} and \code{face_spatial()} to transform between a spatial cubble (\code{cb_nested}) and a temporal one (\code{cb_long}), introduced earlier in subsection \@ref(object):

```{r cubble-fun, echo = TRUE}
identical(face_temporal(cb_nested), cb_long)
identical(face_spatial(cb_long), cb_nested)
```

The pair of verbs are exact inverse and apply both functions on a cubble object will result in the object itself:

```{r cubble-fun2, echo = TRUE}
identical(face_spatial(face_temporal(cb_nested)), cb_nested)
identical(face_temporal(face_spatial(cb_long)), cb_long)
```

```{r face, echo = FALSE, fig.align="center", out.width = "100%", fig.cap = "An illustration of the function \\code{face\\_temporal()} and \\code{face\\_spatial()}: \\code{face\\_temporal()} converts a spatial cubble (neseted form) into a temporal cubble (long form) to focus on the temporal variables. Conversely, \\code{face\\_spatial()} transforms a temporal cubble into a spatial one to emphasize spatial variables."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.001.png"))
```

## Compatibility with tsibble and sf

Analysts often have their preferred spatial or temporal data structure that they prefer to use for spatio-temporal analysis. For example, the \code{tbl_ts} class from the \code{tsibble} package [@tsibble] is commonly used in time series forecasting and similarly, the \code{sf} class [@sf] is frequently used in spatial data science. In \code{cubble}, analysts have the flexibility to combine these two structures together by allowing the spatial component to also be an \code{sf} object and the temporal component to also be a \code{tsibble} object.

### Using a tsibble object as the temporal component

The \code{key} and \code{index} arguments in a \code{cubble} object corresponds to the \code{tsibble} counterparts and they can be safely omitted, if the temporal component is a \code{tsibble} object, i.e. \code{meteo_ts} in the example below. The \code{tsibble} class from the input will be carried over to the \code{cubble} object:

```{r echo = TRUE}
ts_nested <- make_cubble(
  spatial = stations, temporal = meteo_ts, coords = c(long, lat))
(ts_long <- face_temporal(ts_nested))
class(ts_long)
```

The temporal cubble shows \code{[tsibble]} in the header to indicate the object also being in a \code{tbl_ts} class (\code{tsibble}). Methods applies to the \code{tbl_ts} class can also be applied to the temporal cubble objects, for example, checking whether the data contain temporal gaps:

```{r echo = TRUE}
ts_long %>% has_gaps()
```

An existing \code{cubble} object can promote its temporal component to a \code{tsibble} object by applying \code{make_temporal_tsibble()}. The following code illustrates this with the object \code{cb_long} created in section \@ref(create) and the promoted cubble object is equal to the cubble object originally created from a \code{tsibble} object:

```{r echo = TRUE}
ts_long2 <- cb_long %>% make_temporal_tsibble() 
identical(ts_long2, ts_long)
```

### Using an sf object as the spatial component

Similarly, an \code{sf} object can be supplied as the spatial component to create a \code{cubble} object, with the \code{coords} argument being omitted. This opens up the possibility to represent fixed area with polygons or multipolygons (see Applications \@ref(covid)) and the \code{coords} argument will be calculated as the centroids of the (multi)polygons. The \code{[sf]} print in the cubble header suggest an spatial component being also a \code{sf} object:

```{r echo = TRUE}
(sf_nested <- make_cubble(
  spatial = stations_sf, temporal = meteo, 
  key = id, index = date))
class(sf_nested)
```

The \code{sf} functions applicable to a \code{cubble} object have been listed in Table \@ref(tab:funs) and the following code shows how to perform coordinate transformation with \code{st_transform} on a cubble object:

```{r echo =TRUE, message=FALSE}
sf_nested %>% sf::st_transform(crs = "EPSG:3857")
```

The counterpart to promote the spatial component in an existing \code{cubble} to be an \code{sf} object is \code{make_spatial_sf()}:

```{r echo = TRUE}
cb_nested %>% make_spatial_sf() 
```

## Comparison to other spatio-temporal classes {#tidyverse}

In \proglang{R}, there are other existing spatio-temporal data structure and this section compares and contrasts \pkg{cubble} with other existing alternative, specifically \pkg{stars} and \pkg{sftime}. The \pkg{stars} package [@stars] uses an array structure, as oppose to tibble, to represent multivariate spatio-temporal data. While both \pkg{stars} and \pkg{cubble} support vector and raster data, it is a matter of choice on which structure to use given the application. Analysts working on satellite imageries may prefer the array structure in \pkg{stars}, while others originally working with spatio-temporal data in 2D data frames may find \pkg{cubble} easier to adopt from their existing computing workflow.

The \pkg{sftime} package [@sftime] also builds from a tibble object and its focus is on handling irregular spatio-temporal data. This means \pkg{sftime} can also handle full space-time grids and sparse space-time layouts represented in \pkg{cubble}, but \pkg{cubble} uses nesting to avoid storing spatial variables repetitively at each timestamp. This provides memory efficiency when data is observed frequent, i.e. daily or sub-daily, or the spatial geometry is expensive to repeat, i.e. polygons or multipolygons. Consider the \code{climate_aus} data in the \pkg{cubble} package with `r nrow(cubble::climate_aus)` stations observed daily in a single year 2020. The created \code{sftime} object is approximately `r library("cubble"); round(object.size(sftime::st_as_sftime(climate_aus))/object.size(climate_aus))` times larger than the corresponding \code{cubble} object (`r round(object.size(sftime::st_as_sftime(climate_aus))/1e6, 2)` MB vs. `r round(object.size(cubble::climate_aus)/1e6, 2)` MB).

# Other features and considerations {#others}

## Data fusion and matching {#matching}


One common task when working with spatio-temporal data is to match nearby sites. For example, we may want to verify the location of an old list of stations with current stations, or we may want to match the data from different data sources. In cubble, spatial and temporal matching are performed using the functions `match_spatial()` and `match_temporal()`. The `match_spatial()` function calculates the spatial distance between observations in two cubble objects. Various distance measures are available (check `sf::st_distance`). Analysts can specify the number of matched groups to output using the `spatial_n_group` argument (default to 4 groups) and the number of matches per group using the `spatial_n_group` argument (default to 1, one-to-one matching). The syntax to use `match_spatial()` is:
  
````
match_spatial(<cubble_obj1>, <cubble_obj2>, ...)
````

The function `match_temporal()` calculates the similarity between time series within spatially matched groups. Two identifiers are required: one for separating each matched group (`match_id`) and one for separating the two data sources (`data_id`). The argument `temporal_by` uses the `by` syntax from dplyr's `*_join` to specify the temporal variables to match.
  
The similarity score between two time series is calculated using a matching function, which can be customised by the analysts. The matching function takes two time series as a list and returns a single numerical score. This allows for flexibility in using existing time series distance calculation implementation. By default, cubble implements a simple peak matching algorithm (`match_peak`) that counts the number of peaks in two time series that fall within a specified temporal window. The syntax to use `match_temporal()` is
  
````
match_temporal(
  <cubble_obj_from_match_spatial>, 
  data_id = , match_id = , 
  temporal_by = c("..." = "...")
)
````

## Interactive graphics

The workflow with the \code{cubble} class works well with an interactive graphics pipeline (e.g., @buja1988elements; @buja1996interactive;  @sutherland2000orca; @xie2014reactive; @cheng2016enabling) that is available in \proglang{R} with the package \pkg{crosstalk} [@crosstalk]. Figure \ref{fig:illu-interactive} illustrates the linking between a map and multiple time series in a \code{cubble} object. Both the map, generated from the spatial cubble, and the time series plot, generated from the temporal cubble, are shared crosstalk objects. When a user selects a location on the map (a), the corresponding site is highlighted. This selection activates a row in the spatial \code{cubble}, which is then communicated to the temporal \code{cubble}, resulting in the selection of all observations with the same ID in (b). Consequently the temporal \code{cubble} highlights the corresponding series in the time series plot (c). Linking can also be initiated from the time series plot, by selecting points on the time series. This action activates rows with the same ID in the temporal \code{cubble} and the row in the spatial \code{cubble}, which will be highlighted on the map. Please refer to the appendix for the corresponding illustration. 

```{r illu-interactive, echo = FALSE, fig.align="center", out.height = "35%", out.width = "100%", fig.cap = "Linking between multiple plots. The line plots and the map are constructed from shared \\code{crosstalk} objects. When a station is selected on the map (a), the corresponding row in the spatial \\code{cubble} will be activated. This will link to all the rows with the same id in the temporal \\code{cubble} (b) and update the line plot (c)."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.002.png"))
```

## Spatio-temporal transformations {#st_transformation}

Sometimes, we wish to communicate spatial and temporal information collectively through visualisation. This can be achieved through several graphical displays: one can make faceted maps across time, creating map animations, or constructing interactive graphics to link between map and time series plot. The concept of glyph maps was initially proposed in @Wickham2012-yr. The underlying idea is to transform the temporal coordinates into spatial coordinates so that time series plot can be displayed on the map. 

The package `GGally` initially implement the glyph map. It uses `glyphs()` to calculate the axis transformation and then uses `geom_polygon()` to draw the map. In cubble, a ggproto implementation `geom_glyph()` performs the linear algebra internally as data transformation . The `geom_glyph()` requires four aesthetics: `x_major`, `y_major`, `x_minor`, and `y_minor`. The major axes are the outer spatial coordinates and the minor axes are the inner/ temporal coordinates: 

```
data |> 
  ggplot() +
  geom_glyph(aes(x_major = ..., x_minor = ..., 
                 y_major = ..., y_minor = ...))
```

Some useful controls over the glyph map includes:
  
  * polar coordinate glyph maps with \code{polar = TRUE}, 
  * adjust glyph size with arguments \code{width} and \code{height},
  * glyph scale to fixed (\code{global_rescale} defaults to \code{TRUE}) or free, and 
  * reference boxes and lines with \code{geom_glyph_box()} and \code{geom_glyph_line()}.
  
  
# Applications {#examples}

Five examples are chosen to illustrate different aspects of the \pkg{cubble} package: creating a \code{cubble} object from two Coronavirus (COVID) data tables with the complication of differing location names, using spatial transformations to make a glyph map of seasonal temperature changes, matching river level data and weather station records for analysis of water supply, reading NetCDF format data to reproduce a climate reanalysis plot, and the workflow to create complex interactive linked plots.

## Victoria COVID spatio-temporal incidence and spread {#covid}

Since the start of the pandemic, the Victoria State Government in Australia has been providing daily COVID counts per Logal Government Area (LGA). This data can be combined with map polygon data, available from the Australian Bureau of Statistics (ABS), to visualize COVID incidence and spread. In the \pkg{cubble} package, the COVID count data (\code{covid}) and the LGA information (\code{lga}) are available as a \code{tsibble} object and an \code{sf} object respectively.

A cubble object can be created from separate spatial and temporal component using the \code{make_cubble()} function, introduced in Section \@ref(create). The \code{by} argument
is used to specify the joining variable from the two component using the \code{*_join()} \code{by} syntax: 

```{r covid-4, echo = TRUE, warning = TRUE, message= TRUE}
cb <- make_cubble(lga, covid, by = c("lga_name_2018" = "lga"))
```

The warning message suggests the slight difference of LGA encoding used by Victoria government and ABS and prompts analysts to use the function \code{check_key()} to identify the mismatches:

```{r covid-5, echo = TRUE}
(check_res <- check_key(
  spatial = lga, temporal = covid, 
  by = c("lga_name_2018" = "lga")
))
```

The result of the \code{check_key()} function is a list containing three elements: 1) matched keys from both tables, 2) potentially pairable keys, and 3) others. Here, the main mismatch arises from the two LGAs: Kingston and Latrobe (Kingston is a LGA in both Victoria and South Australia and Latrobe is a LGA in both Victoria and Tasmania). Analysts can modify the input spatial and temporal data accordingly and recreate the cubble object: 

```{r covid-6, echo = TRUE}
lga2 <- lga |>
  rename(lga = lga_name_2018) |> 
  mutate(lga = ifelse(lga == "Kingston (C) (Vic.)", "Kingston (C)", lga),
         lga = ifelse(lga == "Latrobe (C) (Vic.)", "Latrobe (C)", lga)) |>
  filter(!lga %in% check_res$others$spatial) 
  
covid2 <- covid |> filter(!lga %in% check_res$others$temporal)

(cb <- make_cubble(spatial = lga2, temporal = covid2))
```

## Australian historical maximum temperature {#historicaltmax}

```{r}
load(here::here("data/historical_tmax.rda"))
```


The GHCN provides daily climate measures from stations across the world. The data used here (\code{historical_tmax}) is a subset extracted using the package \pkg{rnoaa} [@rnoaa], containing the records of maximum temperature for `r nrow(historical_tmax)` Australian stations from `r range(historical_tmax$first_year)[1]` through `r range(historical_tmax$first_year)[2]` and provides information also on the latitude, longitude and elevation of each of the  stations. <!-- This data  is already cast into a \code{cubble} data object (please see Appendix X for the code to extract  the data from XX and prepare the data into \code{cubble} form), with \code{id} as the key, \code{date} as the index, and \code{c(longitude, latitude)} as the coordinates.--> The goal of this example is to compare the monthly average maximum temperature between two periods, 1971-1975 and 2016-2020, for stations in Victoria and New South Wales (NSW), using a glyph map.

First, the stations need to be filtered to those in Victoria and NSW by using the station identifiers, stored within the 11 digits of the \code{id} variable entries. The country code is in the first 5 digits (Australia is represented by "ASN00") and the next 6 digits encode the station following the Australian Bureau of Meteorology (BOM) [@bom] coding protocols. The NSW stations correspond to entries in the range 46-75 and the Victorian stations to 76-90. Filtering Victoria and NSW stations is a *spatial operation* and hence uses the spatial \code{cubble}: 

<!-- BOM link: http://www.bom.gov.au/climate/cdo/about/site-num.shtml -->

```{r echo = TRUE}
tmax <- historical_tmax |>
  filter(between(as.numeric(stringr::str_sub(id, 7, 8)), 46, 90))
```

Next, the monthly maximum average temperature is  calculated for both periods. This is a *temporal operation* requiring a switch into the temporal \code{cubble} using the \code{face_temporal()} function. In addition, a new indicator for the two time periods of interest is created before the calculation of monthly averages:

```{r echo = TRUE}
tmax <- tmax |>
  face_temporal() |> 
  group_by(
    yearmonth = tsibble::make_yearmonth(
      year = ifelse(lubridate::year(date) > 2015, 2016, 1971),
      month = lubridate::month(date))
      )|>
  summarise(tmax = mean(tmax, na.rm = TRUE)) %>% 
  mutate(group = as.factor(lubridate::year(yearmonth)),
         month = lubridate::month(yearmonth))
```

A quick check on the number of observations for each location is made, revealing that there are several with less than 24 observations -- these stations lack temperature values for some months. In this example, those stations are removed by switching to the spatial \code{cubble} to operate on the spatial component over time, and then, move back into the temporal \code{cubble} (to make the glyph map):

```{r echo = TRUE}
tmax <- tmax |> 
  face_spatial() |> 
  rowwise() %>% 
  filter(nrow(ts) == 24) |>
  face_temporal()
```

In order to create a glyph map displaying the monthly series  (Figure \ref{fig:basic-manip}), the spatial variables need to be unfolded with the temporal variables. The reason being that the major (\code{long}, \code{lat}) and minor (\code{month}, \code{tmax}) coordinates need to be on the same table to create the glyph map. The \code{geom_glyph()} function does both the transformation and the plotting. 

```{r eval = FALSE, echo = TRUE}
ggplot() +
  geom_sf(data = MAP_DATA, ...) +
  geom_glyph(data = tmax,
             aes(x_major = long, x_minor = month,
                 y_major = lat, y_minor = tmax,
                 group = interaction(id, group), color = group),
             width = 1, height = 0.5) + 
  ...
```

```{r}
cobar <- tmax |> filter(id == "ASN00048027") |>
  ggplot(aes(x = month, y = tmax, color = group)) +
  geom_line() +
  scale_color_brewer(palette = "Dark2", guide = "none") +
  scale_x_continuous(
    breaks = seq(1, 12, 1),
    labels = c("J", "F", "M", "A",
               "M", "J", "J", "A",
               "S", "O", "N", "D")
    ) +
  labs(x = "", y  = "Temp (C)") +
  theme_bw() + 
  theme(aspect.ratio = 0.3)

```


```{r basic-manip, out.width="100%", fig.height = 5, fig.width = 10, fig.cap="A glyph map of the monthly maximum average temperature for weather stations in  Victoria and New South Wales (NSW) for the periods (1971-1975, 2016-2020). The corresponding average time series for the cobar station are display on the top left corner. From the glyph map we can observe that the monthly trend is similar for all locations (low in the winter, high in the summer), and small increased temperatures, particularly in late summer can be seen at most stations in NSW."}
tmax <- tmax |> unfold(long, lat)
box_df <- tmax |> face_spatial() |> filter(id == "ASN00048027")
nsw_vic <- ozmaps::abs_ste |> filter(NAME %in% c("Victoria","New South Wales"))

p1 <- tmax %>% 
  ggplot(aes(x_major = long, x_minor = month, 
             y_major = lat, y_minor = tmax,
             group = interaction(id, group))) + 
  geom_sf(data = nsw_vic, fill = "grey95", 
          color = "white", inherit.aes = FALSE) + 
  geom_glyph_box(data = tmax, width = 0.8, height = 0.3) +
  geom_glyph(data = tmax, aes(color = group), width = 0.8, height = 0.3) +
    # geom_rect(
    #   data = box_df,
    #   aes(xmin = long - 0.6, xmax = long + 0.6,
    #       ymin = lat - 0.12, ymax = lat + 0.35),
    #   fill = "transparent", color = "black") +
  scale_color_brewer("", palette = "Dark2") + 
  coord_sf(xlim = c(141, 154), ylim = c(-39, -28.5)) + 
  ggthemes::theme_map() +
  theme(legend.position = "bottom", legend.text = element_text(size = 10)) + 
  guides(color = guide_legend(override.aes = list(size=2)))

(p1 | cobar)  + 
  patchwork::plot_layout(width = c(1,1)) + 
  plot_annotation(tag_levels = 'a')

```

Glyph maps work well to explore temporal patterns across spatial locations, particularly when the spatial locations are gridded. In this example, they are irregularly spaced, which can result in overlapping glyphs obscuring each other.


## River levels and rainfall in Victoria

One common task when working with spatio-temporal data is to match nearby sites. For example, we may want to verify the location of an old list of stations with current stations, or we may want to match the data from different data sources. In this example, we will introduce the spatial and temporal matching in cubble using an example on matching river level data with precipitation in Victoria, Australia.

The water level data collected by the Bureau of Meteorology, can be compared with the precipitation since rainfall can directly impact water level in river. Both `climate_vic` and `river` are cubble objects, and we can obtain a summary of the 10 closest pairs between them:



```{r}
climate_vic <- climate_aus |>
  filter(between(as.numeric(stringr::str_sub(id, 7, 8)), 76, 90)) |>
  mutate(type = "climate")
river <- cubble::river %>% mutate(type = "river") 
```


```{r echo = TRUE}
res_sp <- match_spatial(climate_vic, river, spatial_n_group = 10)
print(res_sp, n = 20)
```

The result can also be returned as cubble objects by setting the argument `return_cubble = TRUE`. The output is be a list where each element is a paired cubble object. To combine all the results into a single cubble, you can use `bind_rows()`. In the case when a site in the second cubble (the `river` data here) is matched to two stations in the first cubble (`climate_vic` here), the binding may not be successful since cubble requires unique rows in the nested form. In the summary table above, the river station `226027` is matched to more than one weather station: `ASN00085072` (group 3) and `ASN00085298` (group 5). Similarly, the river station `230200` is matched in group 7 and 8). In such cases, you can either deselect one pair before combining, or work with the list output with the `purrr::map` syntax:


```{r echo = TRUE}
res_sp <- match_spatial(
  climate_vic, river, 
  spatial_n_group = 10, return_cubble = TRUE)
str(res_sp, max.level = 0)
(res_sp <- res_sp[-c(5, 8)] %>% bind_rows())
```

For temporal matching, we match the variable `Water_course_level` from the river data to `prcp` in the weather station data. The variable `group` and `types` identify the matching group and the two datasets:

```{r echo = TRUE}
(res_tm <- res_sp %>% 
  match_temporal(
    data_id = type, match_id = group,
    temporal_by = c("prcp" = "Water_course_level")))
```

Similarly, the cubble output can be returned using the argument `return_cubble = TRUE`. Here we select the four pairs with the highest number of matching peaks:

```{r echo = TRUE}
res_tm <- res_sp %>% 
  match_temporal(
    data_id = type, match_id = group,
    temporal_by = c("prcp" = "Water_course_level"),
    return_cubble = TRUE)
(res_tm <- res_tm %>% bind_rows() %>% filter(group %in% c(1, 7, 6, 9)))
```

Figure \ref{fig:matching} shows four matched pairs on the map (a) and standardized data as time series (b) with concurrent increasing.

```{r matching, out.width="100%", fig.height = 5, fig.width = 10, fig.cap="Weather stations and river gauges with matched pairs labelled on the map (a) and plotted across time (b). Precipitation and water level have been standardised between 0 and 1 to be displayed on the same scale. The water level reflects the increase in precipitation. The numbers (1, 7, 6, 9) indicate the group index derived from spatial matching, only those that were selectd by temporal matching are shown here."}
res_tm <- res_tm %>%  filter(group %in% c(1, 7, 6, 9))

res_tm_long <- res_tm %>%  
  face_temporal() %>%  
  unfold(group, type) %>%  
  group_by(group, type) %>%
  mutate(matched = (matched - min(matched, na.rm = TRUE))/ 
           (max(matched, na.rm = TRUE) - min(matched, na.rm = TRUE))) 

vic_map <- ozmaps::abs_ste |> 
  filter(NAME == "Victoria") |> 
  rmapshaper::ms_simplify()  

p1 <-ggplot() + 
  geom_sf(data = vic_map, fill = "grey95", color = "white") + 
  geom_point(data = dplyr::bind_rows(river, climate_vic), 
             aes(x = long, y = lat, color = type), 
             alpha = 0.2, fill = 0.2) +
  geom_point(data = res_tm %>% as_tibble(), 
             aes(x = long, y = lat, color = type)) +
  ggrepel::geom_label_repel(
    data = res_tm |> filter(type == "river") %>% as_tibble(), 
    aes(x = long, y = lat, label = group)) +
  scale_color_brewer(palette = "Dark2")  + 
  ggthemes::theme_map() +
  ggplot2::theme(legend.position = "bottom",
                 legend.text = element_text(size = 15),
                 legend.title = element_text(size = 15)) +
  ggplot2::labs(x = "Longitude", y = "Latitude") + 
  guides(color = guide_legend(override.aes = list(size=5)))

p2 <- res_tm_long %>%  
  ggplot(aes(x = date, y = matched, group = type,color = type)) + 
  geom_line() + 
  facet_wrap(vars(group)) + 
  scale_color_brewer(palette = "Dark2", guide = "none") + 
  theme_bw() + 
  labs(x=  "date") + 
  scale_x_date(date_labels = "%b") + 
  labs(x = "Week", y = "Precipitation/ water level")

(p1 | p2) + 
  patchwork::plot_layout(guides = "collect") + 
  plot_annotation(tag_levels = 'a')&
  theme(legend.position = "bottom") 
```


## ERA5: climate reanalysis data

The ERA5 reanalysis [@hersbach2020era5] provides hourly estimates of atmospheric, land and oceanic climate variables on a global scale. The hourly pressure level data in the NetCDF format can be downloaded from Copernicus Climate Data Store (CDS) [@cds] or via the \pkg{ecmwfr} package [@ecwmfr]. This example reproduces the row created from ERA5 reanalysis data shown in Figure 19 by @hersbach2020era5. The plot shows the southern polar vortex splitting into two on 2002-09-26, and further splitting into four on 2002-10-04. Further explanation of why this is interesting can be found in the figure source, and also in @simmons2020global and @simmons2005ecmwf.

To work with NetCDF data in R, several packages are available, including \code{ncdf4}, \code{RNetCDF}, and \code{tidync}. The following code converts a NetCDF object of class \code{ncdf4} into a cubble object:

```{r echo = TRUE}
raw <- ncdf4::nc_open(here::here("data/era5-pressure.nc"))
```

Analysts can extract a subset of the NetCDF data with the arguments \code{vars}, \code{long_range} and \code{lat_range}. In this example, the variables q (specific humidity) and z (geopotential) are selected and the coordinates are subsetted to every degree in longitude and latitude: 

```{r echo = TRUE}
(dt <- as_cubble(raw, vars = c("q", "z"),
                 long_range = seq(-180, 180, 1), lat_range = seq(-88, -15, 1)))
```

Once the NetCDF data is coerced into a cubble object, subsequent analysis can be conducted to filter on the date of interest, scale the variable specific humidity and create visualisation in ggplot as in Figure \ref{fig:netcdf}.

```{r netcdf, out.width="100%", fig.height = 4, fig.width = 10, fig.cap = "A reproduction of the second row (ERA5 data) of Figure 19 in Hersbach et al (2020) to illustrate the break-up of sourthern polar vortex in late September and early October 2002. The polar vortex, signalled by the high specific humidity, splits into two on 2002-09-26 and further splits into four on 2002-10-04."}
date <- c("2002-09-22", "2002-09-26", "2002-09-30", "2002-10-04") |> as.Date()
res <- dt |> 
  face_temporal() |> 
  filter(lubridate::date(time) %in% date) |>
  unfold(long, lat) |> 
  mutate(q = q* 10^6)

con <- rnaturalearth::ne_coastline("small", returnclass = "sf")
box <- st_bbox(c(xmin = -180, ymin = -90, xmax = 180, ymax = -15), crs = st_crs(con)) 
sf::sf_use_s2(FALSE)
country <- con %>% st_geometry() %>% 
  sf::st_crop(box) |> 
  sf::st_cast("MULTILINESTRING")

res |> 
  ggplot() +
  # q for specific humidity
  geom_point(aes(x = long, y = lat, color = q)) + 
  #geom_tile(aes(x = long, y = lat, fill = q), color = "transparent") +
  # z for geopotential
  geom_contour(data = res, aes(x = long, y = lat, z = z),
               color = "grey20", binwidth = 4000, linewidth = 0.5) +
  geom_sf(data = country , alpha = 0.5, fill = "transparent", color = "lightgreen") +
  coord_sf(
    crs = "+proj=stere +lat_0=-90 +lon_0=-180 +k=1 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs", default_crs = sf::st_crs(4326), clip = "off") +
  theme_bw() +
  theme(legend.position = "bottom",
        axis.ticks = element_blank(),
        panel.border = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank()) +
  facet_wrap(vars(as.Date(time)), nrow = 1)+  
  colorspace::scale_color_continuous_sequential("Purple-Yellow", name = "Specific humidity") + 
  theme(legend.text = element_text(size = 13),
        legend.title = element_text(size = 13)) + 
  labs(x ="", y = "")
```


```{r eval = FALSE}
# prepare data/era5-pressure.nc
library(ecmwfr)
my_request <- list(
  product_type = "reanalysis",
  format = "netcdf",
  pressure_level = "10",
  year = "2002",
  month = c("09", "10"),
  day = c("04", "22", "26", "30"),
  time = "00:00",
  area = c(-15, -180, -90, 180),
  variable = c("specific_humidity", 'geopotential'),
  dataset_short_name = "reanalysis-era5-pressure-levels",
  target = "era5-pressure.nc"
)
# 
# # here you need to create an account on Climate Data Store 
# # at https://cds.climate.copernicus.eu/cdsapp#!/home) to obtain the user ID and API key
# # then set up the with ecmwfr::wf_set_key(user, key, service = "cds")
# # the user below is the same `user` in the setup line
wf_request(
  user = "113339",
  request = my_request,
  transfer = TRUE,
  path = here::here("data/"))
```

## Australian temperature range

Interactive graphics can be useful because they make it possible to look at the data in multiple ways on-the-fly. This is especially important for spatio-temporal data, where we would like to interactively connect spatial and temporal displays. This example describes the process of using the \pkg{cubble} package with the \pkg{crosstalk} package to build an interactive display connecting a map of Australia, with ribbon plots of temperature range observed at the stations. The purpose is to explore the variation of monthly temperature range over the country. Figure \ref{fig:interactive-linking} shows three snapshots of the interactivity.

The key steps are to convert both the nested and long forms of the data into shared \code{crosstalk} objects, and to plot these side-by-side. The two are linked by the station identifier.

``` r
clean <- climate_full |> ...

nested <- clean |> SharedData$new(~id, group = "cubble")
long <- face_temporal(clean) |> SharedData$new(~id, group = "cubble")

p1 <- nested |> ...
p2 <- long |> ...

crosstalk::bscols(plotly::ggplotly(p1), plotly::ggplotly(p2), ...)

```

Plot (a) shows the initial state of the interactive display: all locations are shown as dots on the map, coloured by temperature range, and the right plot shows the ribbons representing maximum to minimum for all stations. In plot (b) the "Mount Elizabeth" station, which shows a high variance colour on the initial map, is selected on the map and this produces the ribbon on the right. In plot (c) the lowest temperature in August is selected, which is "Thredbo" station on the left map. It was surprising to us that this was not a station in Tasmania, so for comparison a station in Tasmania is selected on the map to show in relation to Thredbo. We can see that Thredbo has a bigger winter dip in temperature, and although Tasmania is cold generally, it's temperatures are more constant

```{r eval = FALSE}
# This chunk generates the interactive graphic and save it as figures/linking.html, where the three screencasts in the figure comes from.
library("crosstalk")
library("plotly")

clean <- climate_full |>
  filter(!id %in% c("ASN00067033", "ASN00072091", "ASN00059040", 
                    "ASN00097053", "ASN00040856", "ASN00015548")) |>
  face_temporal() |> 
  mutate(month = lubridate::month(date)) |>
  group_by(month) |>
  summarise(
    tmax = mean(tmax, na.rm = TRUE),
    tmin = mean(tmin, na.rm = TRUE),
    diff = mean(tmax - tmin, na.rm = TRUE)
    ) |> 
  ungroup(month) |>
  mutate(dummy_date = as.Date(glue::glue("2021-{month}-01"))) |> 
  face_spatial() |> 
  mutate(temp_diff_var = ts |> pull(diff) |> var(na.rm = TRUE))
  
nested <- clean |> 
  SharedData$new(~id, group = "cubble")

long <- clean |> 
  face_temporal() |> 
  unfold(temp_diff_var) |> 
  arrange(temp_diff_var) |> 
  SharedData$new(~id, group = "cubble")

state_map <- rmapshaper::ms_simplify(ozmaps::abs_ste, keep = 2e-3)

p1 <- nested |> 
  ggplot() +
  geom_sf(data = state_map, fill = "grey95", color = "white") +
  geom_point(aes(x = long, y = lat,color = temp_diff_var, label = name)) +
  colorspace::scale_color_continuous_sequential(
    "Rocket",  n_interp = 7, cmax = 90, rev = TRUE, 
    c2 = 40, l2= 85, c1 = 20, l1 = 30, name = "Var. temp. diff.") +
  labs(x = "Longitude", y = "Latitude") + 
  coord_sf() + 
  theme_bw() + 
  theme(
    panel.grid.major = element_blank(),
    legend.position = "none"
    )

p2 <- long |> 
  ggplot(aes(x = dummy_date, group = id, 
             fill = temp_diff_var, color = temp_diff_var)) +
  geom_ribbon(aes(ymin = tmin, ymax = tmax), size = 0.1, alpha = 0.3) + 
  geom_line(aes(y = tmin), alpha = 0.1) + 
  geom_line(aes(y = tmax), alpha = 0.1) + 
  geom_point(aes(y = tmax), size = 0.1) + 
  geom_point(aes(y = tmin), size = 0.1) + 
  colorspace::scale_fill_continuous_sequential(
    "Rocket",  n_interp = 7, cmax = 90, rev = TRUE, 
    c2 = 40, l2= 85, c1 = 20, l1 = 30, name = "Var. temp. diff.") +
  colorspace::scale_colour_continuous_sequential(
    "Rocket",  n_interp = 7, cmax = 90, rev = TRUE, 
    c2 = 40, l2= 85, c1 = 20, l1 = 30, name = "Var. temp. diff.") +
  scale_x_date(date_labels = "%b", date_breaks = "1 month") + 
  labs(x = "Month", y = "Temperature") + 
  theme_bw() + 
  theme(
    panel.grid.major = element_blank(),
    legend.position = "bottom"
    )

out <- bscols(
  ggplotly(p1, width = 900, height = 700, tooltip = "label") |>
    highlight(
      on = "plotly_selected", 
      off = "plotly_deselect", 
      opacityDim = 0.1),
  ggplotly(p2, width = 1200, height = 700, tooltip = "label") |> 
    highlight(
      on = "plotly_selected", 
      off = "plotly_deselect", 
      opacityDim = 0.012),
  widths = c(5, 5)
)

htmltools::save_html(out, file = "figures/linking.html")

```


```{r interactive-linking, echo = FALSE, out.width="100%", out.height="23%", fig.retina = 2, dpi = 300, fig.cap = "Exploring temperature variation using linking of a map and seasonal display. Each row is a screen dump of the process. The top row shows all locations and all temperature profiles. Selecting a particular location on the map (here Mount Elizabeth) produces the plot in the second row. The maximum and minimum temperatures are shown using a ribbon. The bottom row first selects the lowest temperature in August in the seasonal display, which highlights the corresponding station on the map (Thredbo). Another  station, located in the Tasmania Island, is then selected to compare its temperature variation with the Thredbo station.", fig.show='hold'}
knitr::include_graphics(here::here("figures/linking.png"))
knitr::include_graphics(here::here("figures/linking-north.png"))
knitr::include_graphics(here::here("figures/linking-lower.png"))
```

# Conclusion {#conclude}



This paper presents the \proglang{R} package \pkg{cubble} for organizing, wrangling and visualizing spatio-temporal data. The package introduces a new data class, \code{cubble}, consisting of two subclass, spatial cubble and a temporal cubble, to organise spatio-temporal data in two different formats within the tidy data framework. The data structure and functions introduced in this package can be used and combined with existing spatial and temporal data analysis packages such as \pkg{sf} and \pkg{tsibble}, data wrangling packages such as \pkg{dplyr}, and visualization packages such as \pkg{ggplot2}, \pkg{plotly}, and \pkg{leaflet}.

The paper includes numerous examples to illustrate the utility of \pkg{cubble} as a data structure for spatio-temporal analysis. These examples cover different tasks of a typical analysis workflow: handling data with spatial and temporal misalignment, matching data from multiple sources, and creating both static and interactive spatio-temporal visualisation. For future directions, other commonly-used spatial or temporal data structures can be integrated into \pkg{cubble} to extend analysts' familiar spatial and temporal toolkit to spatio-temporal.

# Acknowledgement

This work is funded by a Commonwealth Scientific and Industrial Research Organisation (CSIRO) Data61 Scholarship and started while Nicolas Langrené was affiliated with CSIRO's Data61. The article is created using the package \pkg{knitr} [@knitr] and \pkg{rmarkdown} [@rmarkdown] in \proglang{R} with the \code{rticles::jss_article} template. The source code for reproducing this paper can be found at: https://github.com/huizezhang-sherry/paper-cubble.
