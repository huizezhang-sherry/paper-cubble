---
title: "2-the-cubble-pkg"
output: pdf_document
---

# The cubble package {#cubble}

## The cubble object {#object}

Spatio-temporal data can encompass data with various spatial and temporal characteristics and different data require different structures for wrangling and analysis: climate weather stations record data at fixed point location but may suffer from potential temporal data quality issue such as missing data for certain days. GPS data tracks unique point locations at different timestamps and is represented as trajectories. Satellite imageries capture snapshots of landscapes at selected time and is commonly structured as raster data. The spatio-temporal data cubble address are those collected at unique fixed locations while allowing for irregularity in the temporal dimension, such as the weather station data. This corresponds to the full space-time and sparse space-time layouts described in the spacetime paper [@spacetime] and reproduced in Figure  \ref{fig:layout}.

```{r layout, echo = FALSE, fig.cap="The full space-time and sparse space-time layouts handled by the cubble package. Reproduced from Figure 1 in the spacetime paper \\citep{spacetime}.", fig.width = 8, fig.height=4, fig.align='center'}
library(tidyverse)
library(patchwork)
p1 <- tibble(
  id = 1:12,
  x = rep(1:4, each = 3),
  y = rep(1:3, 4)
) %>% 
  ggplot(aes(x = as.factor(x) ,y = as.factor(y))) + 
  geom_point() + 
  geom_text(aes(y = y - 0.2, label = id)) + 
  theme_bw() + 
  theme(aspect.ratio = 1) + 
  scale_x_discrete(labels = c("1st", "2nd", "3rd", "4th")) + 
  scale_y_discrete(labels = c("1st", "2nd", "3rd", "4th")) + 
  labs(x = "Time points", y = "Spatial features", title = "STF: full grid layout") 

p2 <- tibble(
  id = 1:7,
  x = c(1, 1, 1, 2, 2, 3, 4),
  y = c(1, 2, 3, 2, 3, 1, 2),
  label = c("1[1,1]", "2[1,2]", "3[1,3]", "4[2,2]", "5[3,2]", "6[1,3]", "7[2,4]")
) %>% 
  ggplot(aes(x = as.factor(x) ,y = as.factor(y))) + 
  geom_point() + 
  geom_text(aes(y = y - 0.2, label = label)) + 
  theme_bw() + 
  theme(aspect.ratio = 1) + 
  scale_x_discrete(labels = c("1st", "2nd", "3rd", "4th")) + 
  scale_y_discrete(labels = c("1st", "2nd", "3rd", "4th")) + 
  labs(x = "Time points", y = "Spatial features", title = "STS: sparse grid layout") 

p1 | p2
```

The cubble class is an S3 class built on tibble that allows the spatio-temporal data to be wrangled in two forms:  a nested form (spatial cubble) and a long form (temporal cubble). It consists of two subclasses:

-   a spatial cubble with class `c("spatial_cubble_df", "cubble_df")`
-   a emporal cubble with class `c("temporal_cubble_df", "cubble_df")`

In a spatial cubble, spaital variables are organised as columns and temporal variables are nested within a specialised `ts` column. The cubble object printed below contains weather records in three airport stations (the creation of a cubble object will be explained in Section \@ref(create)). This toy data is a subset of a larger data \code{climate_aus} collected from Global Historical Climatology Network Daily (GHCND). It records three airport stations located in Melbourne, Australia and includes spatial variables such as station ID, longitude, latitude, elevation, station name, World Meteorology Organisation ID. The dataset contains temporal variables including precipitation, maximum and minimum temperature, which can be read from the cubble header:

```{r}
cb_nested <- climate_mel
```

```{r echo = TRUE}
cb_nested
```

<!-- A nested cubble header prints the key and index variable name and its form. The spatial extent is given by the bounding box with CRS information (missing here). The nested cubble header also shows the name of temporal variables nested in the \code{ts} column and their variable types: \code{prcp [dbl], tmax [dbl], tmin [dbl]}. -->

In a temporal cubble, temporal variables are expanded in the long form and spatial variables are stored as a data attribute:

```{r}
cb_long <- face_temporal(climate_mel)
```

```{r echo = TRUE}
cb_long
```

### The cubble attributes

```{r class, fig.align="center", out.width = "100%", fig.cap = "Illustration of a cubble object in the long form and nested form, along with the associated attributes."}
#knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.004.png"))
```

A cubble object inherits the attributes from tibble (and its subclasses): `class`, `row.names`, and `names`. Additionally, it has three specialised attributes: `key`, `index`, and `coords`. Readers who are familiar with the `key` and `index` attributes from the `tsibble` package would already understand the two arguments. In cubble, the `key` attribute identifies the row in the spatial cubble (given the use of `tidyr::nest()` for nesting), and when combined with the `index` argument, it identifies the row in the temporal cubble. Currently, cubble only supports one variable as the key, and the accepted temporal classes for index includes the base R classes `Date`, `POSIXlt`, `POSIXct`, as well as tsibble's `yearmonth`, `yearweek`, and `yearquarter` classes.

The `coords` attribute represents an ordered pair of coordinates. It can be either an unprojected pair of longitude and latitude, or a projected easting and northing value. The `sf` package is used under the hood to calculate the bounding box, displayed in the header of a spatial cubble.

The temporal cubble has a special attribute called `spatial` to store the spatial variables. Shortcut functions are available to extract attributes, for example, \code{spatial()} for extracting spatial variables from the temporal cubble: 

```{r echo = TRUE}
spatial(cb_long)
```

## Creation and coercion {#create}

In many cases, spatio-temporal data arrive in separate tables for analysis. For example, in climate data, analysts may initially receive station data containing geographic location information, recorded variables and their recording periods. They can then query the temporal variables using the stations of interest to obtain the relevant temporal data. Alternatively, analyses may begin as purely spatial or temporal, and analysts may obtain additional temporal or spatial data to expand the result to spatio-temporal.

The function \code{make_cubble()} composes a \code{cubble} object from a spatial table (\code{spatial}) and a temporal table (\code{temporal}), along with three attributes introduced in the subsection \@ref(object): \code{key}, \code{index}, and \code{coords}. The following code creates the spatial \code{cubble} object shown previously:

```{r echo = TRUE, eval = FALSE}
make_cubble(spatial = stations, temporal = meteo,
            key = id, index = date, coords = c(long, lat))
```

Spatio-temporal data in other foreign objects can be coerced into a \code{cubble} object with the function \code{as_cubble()}. This includes casting from a \code{tibble} or \code{data.frame} with both spatial and temporal information, a NetCDF object, a \code{stars} object [@stars], and a \code{sftime} object [@sftime]. The two examples below show the casting from a tibble and a NetCDF object. The dataset \code{climate_flat} combines the spatial data, \code{stations}, with the temporal data, \code{meteo}, into a single tibble object. It can be coerced into a cubble using:

```{r echo = TRUE}
climate_flat |> as_cubble(key = id, index = date, coords = c(long, lat))
```

## Functions and methods

Table \@ref(tab:funs) summarises the functions implemented in the \pkg{cubble} package and Table \@ref(tab:methods) details the methods implemented for each of the three cubble classes. The \code{cubble_df} class handles methods that behave consistently in both spatial (\code{spatial_cubble_df}) and temporal cubble (\code{temporal_cubble_df}). When the method has distinct behavior for the spatial cubble and temporal cubble, it is implemented separately for each subclass.

| Category  | Functions |
|--------|--------------------------------------------------------|
| base R    | `[`, `[[<-`, `names<-` |
| tidyverse | `dplyr_row_slice`, `dplyr_col_modify`, `dplyr_reconstruct`, `select`, `mutate`, `arrange`, `filter`, `group_by`, `ungroup`, `summarise`, `select`, `slice`, `rowwise`, `rename`, `bind_rows`, `bind_cols`, `relocate`, `type_sum`, the slice family (`slice_head`, `slice_tail`, `slice_max`, `slice_min`, `slice_sample`) and the join family (`left_join`, `right_join`, `inner_join`, `full_join`, `anti_join`, `semi_join`) |
| cubble    | `as_cubble`, `cubble`, `make_cubble`, `check_key` `face_temporal`, `face_spatial`, `unfold`, `key`, `key_vars`, `key_data`, `index`, `index_var`, `coords`, `spatial`, `match_sites`, `match_spatial`, `match_temporal`, `geom_glyph`, `geom_glyph_box`, `geom_glyph_line`, `make_spatial_sf`, `make_temporal_tsibble`, `fill_gaps`, and `scan_gaps`                                                                                |

: (#tab:funs) Functions implemented in the \pkg{cubble} package

| Class                | Methods|
|------------------|------------------------------------------------------|
| `cubble_df`          | `[[<-, dplyr_col_modify, key_data, key_vars, key, print`                                                                                                                                                                                     |
| `spatial_cubble_df`  | `[, names<-,  tbl_sum, dplyr_reconstruct, dplyr_row_slice, face_spatial, face_temporal, unfold, arrange, rename, rowwise, group_by, ungroup, select, spatial, summarise, unfold, update_cubble`                                              |
| `temporal_cubble_df` | `[, names<-, tbl_sum, arrange, dplyr_reconstruct, dplyr_row_slice, face_spatial, face_temporal, unfold, fill_gaps, group_by, ungroup,  rename, rowwise, scan_gaps, select, spatial, summarise, tbl_sum, bind_rows, bind_cols, update_cubble` |

: (#tab:methods) Methods implemented for the three \code{cubble} classes.

Specifically, the pair of verbs, \code{face_temporal()} and \code{face_spatial()}, pivot the cubble object between the spatial and temporal face of the multivariate spatio-temporal cube, as illustrated in Figure \ref{fig:face}. The code below uses the function \code{face_temporal()} and \code{face_spatial()} to transform between a spatial cubble (\code{cb_nested}) and a temporal one (\code{cb_long}), introduced earlier in subsection \@ref(object):

```{r cubble-fun, echo = TRUE}
identical(face_temporal(cb_nested), cb_long)
identical(face_spatial(cb_long), cb_nested)
```

The pair of verbs are exact inverse and apply both functions on a cubble object will result in the object itself:

```{r cubble-fun2, echo = TRUE}
identical(face_spatial(face_temporal(cb_nested)), cb_nested)
identical(face_temporal(face_spatial(cb_long)), cb_long)
```

```{r face, echo = FALSE, fig.align="center", out.width = "100%", fig.cap = "An illustration of the function \\code{face\\_temporal()} and \\code{face\\_spatial()}: \\code{face\\_temporal()} converts a spatial cubble (neseted form) into a temporal cubble (long form) to focus on the temporal variables. Conversely, \\code{face\\_spatial()} transforms a temporal cubble into a spatial one to emphasize spatial variables."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.001.png"))
```

## Compatibility with tsibble and sf

Analysts often have their preferred spatial or temporal data structure that they prefer to use for spatio-temporal analysis. For example, the \code{tbl_ts} class from the \code{tsibble} package [@tsibble] is commonly used in time series forecasting and similarly, the \code{sf} class [@sf] is frequently used in spatial data science. In \code{cubble}, analysts have the flexibility to combine these two structures together by allowing the spatial component to also be an \code{sf} object and the temporal component to also be a \code{tsibble} object.

### Using a tsibble object as the temporal component

The \code{key} and \code{index} arguments in a \code{cubble} object corresponds to the \code{tsibble} counterparts and they can be safely omitted, if the temporal component is a \code{tsibble} object, i.e. \code{meteo_ts} in the example below. The \code{tsibble} class from the input will be carried over to the \code{cubble} object:

```{r echo = TRUE}
ts_nested <- make_cubble(
  spatial = stations, temporal = meteo_ts, coords = c(long, lat))
(ts_long <- face_temporal(ts_nested))
class(ts_long)
```

The temporal cubble shows \code{[tsibble]} in the header to indicate the object also being in a \code{tbl_ts} class (\code{tsibble}). Methods applies to the \code{tbl_ts} class can also be applied to the temporal cubble objects, for example, checking whether the data contain temporal gaps:

```{r echo = TRUE}
ts_long %>% has_gaps()
```

An existing \code{cubble} object can promote its temporal component to a \code{tsibble} object by applying \code{make_temporal_tsibble()}. The following code illustrates this with the object \code{cb_long} created in section \@ref(create) and the promoted cubble object is equal to the cubble object originally created from a \code{tsibble} object:

```{r echo = TRUE}
ts_long2 <- cb_long %>% make_temporal_tsibble() 
identical(ts_long2, ts_long)
```

### Using an sf object as the spatial component

Similarly, an \code{sf} object can be supplied as the spatial component to create a \code{cubble} object, with the \code{coords} argument being omitted. This opens up the possibility to represent fixed area with polygons or multipolygons (see Applications \@ref(covid)) and the \code{coords} argument will be calculated as the centroids of the (multi)polygons. The \code{[sf]} print in the cubble header suggest an spatial component being also a \code{sf} object:

```{r echo = TRUE}
(sf_nested <- make_cubble(
  spatial = stations_sf, temporal = meteo, 
  key = id, index = date))
class(sf_nested)
```

The \code{sf} functions applicable to a \code{cubble} object have been listed in Table \@ref(tab:funs) and the following code shows how to perform coordinate transformation with \code{st_transform} on a cubble object:

```{r echo =TRUE, message=FALSE}
sf_nested %>% sf::st_transform(crs = "EPSG:3857")
```

The counterpart to promote the spatial component in an existing \code{cubble} to be an \code{sf} object is \code{make_spatial_sf()}:

```{r echo = TRUE}
cb_nested %>% make_spatial_sf() 
```

## Comparison to other spatio-temporal classes {#tidyverse}

In \proglang{R}, there are other existing spatio-temporal data structure and this section compares and contrasts \pkg{cubble} with other existing alternative, specifically \pkg{stars} and \pkg{sftime}. The \pkg{stars} package [@stars] uses an array structure, as oppose to tibble, to represent multivariate spatio-temporal data. While both \pkg{stars} and \pkg{cubble} support vector and raster data, it is a matter of choice on which structure to use given the application. Analysts working on satellite imageries may prefer the array structure in \pkg{stars}, while others originally working with spatio-temporal data in 2D data frames may find \pkg{cubble} easier to adopt from their existing computing workflow.

The \pkg{sftime} package [@sftime] also builds from a tibble object and its focus is on handling irregular spatio-temporal data. This means \pkg{sftime} can also handle full space-time grids and sparse space-time layouts represented in \pkg{cubble}, but \pkg{cubble} uses nesting to avoid storing spatial variables repetitively at each timestamp. This provides memory efficiency when data is observed frequent, i.e. daily or sub-daily, or the spatial geometry is expensive to repeat, i.e. polygons or multipolygons. Consider the \code{climate_aus} data in the \pkg{cubble} package with `r nrow(cubble::climate_aus)` stations observed daily in a single year 2020. The created \code{sftime} object is approximately `r library("cubble"); round(object.size(sftime::st_as_sftime(climate_aus))/object.size(climate_aus))` times larger than the corresponding \code{cubble} object (`r round(object.size(sftime::st_as_sftime(climate_aus))/1e6, 2)` MB vs. `r round(object.size(cubble::climate_aus)/1e6, 2)` MB).
