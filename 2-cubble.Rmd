---
title: "2-the-cubble-pkg"
output: pdf_document
---

# The cubble package {#cubble}

## The cubble object {#object}

<!-- Spatio-temporal data can be conceptualized using a cubical data model with three axes which typically are, time, latitude and longitude. This abstraction can be useful for generalizing operations and visualization purposes: @lu_multidimensional_2018 shows how array operations (select, scale, reduce, rearrange, and compute) can be mapped onto the cube; @bach_review_2014 reviews the temporal data visualization based on space-time cube operations. Notice that the term space-time cube in their article "does not need to involve spatial data", but refers to "an abstract 2D substrate that is used to visualize data at a specific time". Despite its main focus being on temporal data, the mindset of abstracting out data representation to construct visualizations, still applies to our spatio-temporal data manipulation and visualization approaches. -->

<!-- The most common space-time cube uses the three axes, time, latitude, longitude, and can be considered stacking space across time. Ours is a multivariate spatio-temporal cube with the three axes defined to be time, site and variables, as illustrated in the leftmost column of Figure \ref{fig:cube-def}. The time axis is the same in both versions, while the site axis now captures both latitude and longitude. Finally, variables are stacked on this space-time canvas, with one observation per site and time point. This notion is adopted to avoid using hyper-cubes when describing multivariate spatio-temporal data and is the conceptual framework behind the \code{cubble} class. With this conceptual model, operations on spatio-temporal data can be mapped to operations on the cube and the rest of Figure \ref{fig:cube-def} show examples of slicing on site, time, and variable.  -->


*the conceptual framework + nested and long form as per the design vignette*

  - diagram, 
  - two forms: long/ nested - spatial/ temporal
  - attributes
  - headers
  
 
The \code{cubble} class is an S3 class [@advr] built on the \code{tibble} class, specifically to organize spatio-temporal data. The \code{cubble} class uses an attribute "form",  to arrange the spatial or temporal data components tidily. The form attribute can take a value of either "nested" or "long". The nested \code{cubble} is a subclass of rowwise \code{tibble} (\code{rowwise_df}). It arranges each spatial site in a row, and uses list columns to store the feature geometry and the temporal information. The long \code{cubble} is a subclass of grouped \code{tibble} (\code{grouped_df}), which expands the temporal information into the long form and stores the spatial information in a "spatial" attribute.

The arguments \code{key} and \code{index} follow the conventions in the \pkg{tsibble} package to describe the temporal order and multiple series while \code{coords} specifies the spatial location of each site. 

```{r}
cb_nested <- climate_mel
```

```{r echo = TRUE}
cb_nested
class(cb_nested)
```

Printing a \code{cubble} object provides some information about the data. Here \code{id} is the variable name to identify each location and there are five unique locations. The bounding box is \code{[115.97, -32.94, 133.55, -12.42]} and provides information about the coordinates in the data. The third row shows the name and type of all variables nested in the \code{ts} column. In this example, it includes \code{date [date], prcp [dbl], tmax [dbl], tmin [dbl]}.

The first line in the header now shows it in the long form and the third line has been changed to display the name and type of spatial variables: \code{lat [dbl], long [dbl], elev [dbl], name [chr], wmo_id [dbl]}. Unlike the nested form, the long \code{cubble} is built from a \code{grouped_df} class where all the observations from the same site form a group.

The nested form can be used for those operations where the output is only indexed by the spatial identifier (\code{key}), but becomes inadequate when outputs need both a spatial and a temporal identifier (\code{key} and \code{index}). The \code{cubble} class also provides a long form, which expands the \code{ts} column and stores the spatial variables as an attribute. The function \code{face_temporal()} is used to switch from the nested \code{cubble} into the long one. The first row in Figure  illustrates this operation where the focus of the cube now changes from the site-variable face to the time-variable face. 


```{r}
cb_long <- face_temporal(climate_mel)
```

```{r echo = TRUE}
cb_long
class(cb_long)
```


<!-- The data \code{climate_flat} is used to illustrate functionality in the \pkg{cubble} package. This is a subset from National Oceanic and Atmospheric Administration (NOAA) [@noaa] Global Historical Climatology Network (GHCN) Daily data. It contains spatial variables, station id, latitude, longitude, elevation, station name, world meteorology organisation id, in additional to daily temporal information,  maximum and minimum temperature values and precipitation records for year 2020. The first five rows of the data are shown below: -->

## Creation and coercion {#create}

### Creating from separate spatial and temporal tables

Spatio-temporal data may arrive in separate tables for analysts. For example, in climate data, analysts may initially receive station data containing geographic location information, variables recorded and their recording periods. They can then query the temporal variables using the stations of interest to obtain the corresponding temporal data. Alternatively, analyses may begin as purely spatial or temporal, and analysts may obtain additional temporal or spatial data to expand the result to spatio-temporal.

The function \code{make_cubble()} composes a \code{cubble} object from a spatial table (\code{spatial}) and a temporal table (\code{temporal}) with the three attributes introduced in the subsection \@ref(object):  \code{key}, \code{index}, and \code{coords}. The following code creates the nested \code{cubble} object shown previously:

```{r echo = TRUE, eval = FALSE}
make_cubble(spatial = stations, temporal = meteo,
            key = id, index = date, coords = c(long, lat))
```

The \code{key} and \code{index} arguments corresponds to the \code{tsibble} counterpart and \code{coords} derives from the geometry column in an \code{sf} object. Hence, the corresponding argument can be safely omitted, if the spatial data is an \code{sf} object, i.e. \code{stations_sf}, or the temporal data is a \code{tsibble} object, i.e. \code{meteo_ts}. The \code{sf} and \code{tsibble} class from the input will be carried over to the \code{cubble} object:

```{r echo = TRUE}
(res <- make_cubble(spatial = stations_sf, temporal = meteo_ts))
class(res)
class(res$ts[[1]])
```


### Coercing from foregin objects

Spatio-temporal data in other foreign objects can be coerced into a \code{cubble} object with the function \code{as_cubble()}. This includes casting from a \code{tibble} or \code{data.frame} with both spatial and temporal information, a NetCDF object, a \code{stars} object [@stars], and a \code{sftime} object [@sftime]. The two examples below show the casting from a tibble and a NetCDF object to a cubble object.

The dataset \code{climate_flat} joins the spatial data, \code{stations}, with the temporal data, \code{meteo}, into a single tibble object and it can be coerced into a cubble using:

```{r echo = TRUE, eval = FALSE}
climate_flat |> as_cubble(key = id, index = date, coords = c(long, lat))
```

The NetCDF data is another format commonly used for storing spatio-temporal data. In \proglang{R}, packages for wrangling NetCDF data include a high-level R interface: \pkg{ncdf4} [@ncdf4], a low-level interface that calls a C-interface: \pkg{RNetCDF} [@rnetcdf], and a tidyverse implementation: \pkg{tidync} [@tidync]. The code below casts a NetCDF object in the \code{ncdf4} class into a cubble object:

```{r echo = TRUE}
path <- system.file("ncdf/era5-pressure.nc", package = "cubble")
raw <- ncdf4::nc_open(path)
as_cubble(raw)
```

Sometimes, one may want to read in a subset of the NetCDF data and the argument \code{vars}, \code{long_range} and \code{lat_range} can be used to subset on the variable and the grid resolution:

```{r echo = TRUE, eval = FALSE}
as_cubble(raw, vars = "q",
          long_range = seq(-180, 180, 1), lat_range = seq(-90, 90, 1))
```

We would recommend reducing to about 300 $\times$ 300 grid points for three daily variables in one year. A 300 by 300 spatial grid can be a bounding box of [100, -80, 180, 0] at 0.25 degree resolution or a global bounding box [-180, -90, 180, -90] at 1 degree resolution.

## Functionalities

Table \@ref(tab:funs) summarises functions implemented in the \pkg{cubble} package.

Table: (\#tab:funs) Functions implemented in the \pkg{cubble} package

|Category | Details |  Functions|
|---|---|--------------|
|base R | subset | `[`, `[<-`, `names<-`, `[[`, `[[<-`| 
|tidyverse | dplyr |`dplyr_row_slice`, `dplyr_col_modify`, `dplyr_reconstruct`, `select`, `mutate`, `arrange`, `filter`, `summarise`, `slice`, `group_by`, `ungroup`|
|tidyverse| tidyr| | 
|tidyverse| pillar| `type_sum` | 
|sf| | | 
|tsibble| | | 
|cubble | basics| `face_temporal`, `face_spatial`, `unfold`|
| | attributes| `key`, `key_vars`, `key_data`, `index`, `index_var`, `coords`, `spatial`|
| |hierarchy|  `switch_key`|
| |matching |   `match_sites`, `match_spatial`, `match_temporal`| 
| |glyph map | `geom_glyph`, `geom_glyph_box`, `geom_glyph_line`|

### dplyr and tidyr

The \pkg{dplyr} package has many tools for wrangling tidy data,  many of which are useful in the spatio-temporal analysis. The \pkg{cubble} package provides methods that support the use of the following operations in the \pkg{dplyr} package on both the nested and long forms: `mutate`, `filter`, `summarise`, `select`, `arrange`, `rename`, `left_join`, and the slice family (`slice_*`).

The toy example below demonstrates using dplyr verbs on a nested cubble: 
```{r echo = TRUE}
cb_nested %>% 
  mutate(avg_temp = mean(ts$tmax, na.rm = TRUE)) %>% 
  select(-elev) %>% 
  filter(avg_temp > 26) %>% 
  arrange(-avg_temp)
```

### cubble 

The three basic cubble functions, \code{face_temporal()}, \code{face_spatial()}, and \code{unfold()}, are introduced in this section before more advanced functionalities in Section \@ref(others).

The pair of verbs, \code{face_temporal()} and \code{face_spatial()}, pivot the cubble object between the spatial and temporal face of the multivariate spatio-temporal cube, as illustrated in Figure \ref{fig:face}. The code below uses the function \code{face_temporal()} and \code{face_spatial()} to transform between a nested cubble (\code{cb_nested}) and a long one (\code{cb_long}), introduced earlier in subsection \@ref(object): 

```{r echo = TRUE}
identical(face_temporal(cb_nested), cb_long)
identical(face_spatial(cb_long), cb_nested)
```

The pair of verbs are exact inverse and apply both functions on a cubble object will result in the object itself: 

```{r echo = TRUE}
identical(face_spatial(face_temporal(cb_nested)), cb_nested)
identical(face_temporal(face_spatial(cb_long)), cb_long)
```

```{r face, echo = FALSE, fig.align="center", out.width = "100%", fig.cap = "An illustration of the function \\code{face\\_temporal()} and \\code{face\\_spatial()}: \\code{face\\_temporal()} converts a spatial cubble (neseted form) into a temporal cubble (long form) to focus on the temporal variables. Conversely, \\code{face\\_spatial()} transforms a temporal cubble into a spatial one to emphasize spatial variables."}
knitr::include_graphics(here::here("figures/diagram-keynotes/diagram-keynotes.002.png"))
```

Sometimes, analysts may need to apply some variable transformation that involves both the spatial and temporal variables. An example of this is the transformation of temporal variables into the spatial dimension in glyph maps [@Wickham2012-yr]. (How to make glyph maps will be explained in Section \ref{st_transformation}, and are illustrated in the second example.) This type of operation can be seen as flattening, or *unfolding*, the cube into a 2D data frame. Here the function \code{unfold()} moves the spatial variables \code{long} and \code{lat} into the long \code{cubble}:

```{r echo = TRUE}
cb_long |> unfold(long, lat)
```

## Compatibility with other packages

\subsubsection[]{\code{tsibble}}

The \code{tsibble} class is a subclass of \code{tibble} where the \code{index} and \code{key} components are used to store temporal and strata information, that makes working with temporal data cognitively efficient. A \code{cubble} object can use the \code{tsibble} class to store the temporal information, and effectively utilize the specialist time series operations in the \pkg{tsibble} package. A \code{tsibble} object can also be casted into a \code{cubble} object through supplying the coordinate information in the argument `coords`:

```{r echo = TRUE}
cb <- make_cubble(
  spatial = stations, temporal = meteo_ts, 
  coords = c(long, lat))
```

When a nested \code{cubble} is created, each element in the list-column \code{ts} is in the \code{tsibble} class (labelled \code{tbl_ts})  and operations available to the \code{tsibble} class are still valid on these elements. For example, the code below calculates two time series features (mean and variance) of maximum temperature, utilizing the \code{tsibble} syntax in the \code{cubble} object:

```{r echo = TRUE}
cb %>% face_temporal() %>% tsibble::has_gaps()
```


\subsubsection[]{\code{sf} (\code{s2})} 

*add an example on changing CRS?*

The \code{sf} class is also a subclass of \code{tibble} with a specialized feature geometry list-column (\code{sfc}) to store different geometry types (\code{POINT}, \code{LINESTRING}, \code{POLYGON}, \code{MULTIPOLYGON}, etc). The package \pkg{sf} provides functions that operate efficiently on this spatial information. A \code{cubble} object can store spatial information in  the \code{sf} class. Methods for the \code{sfc} class can be applied in the nested form of the cubble object.  An illustration is in Section \@ref(covid). The spatial information can also be stored as an \code{s2} vector in a \code{cubble} object.

```{r echo = TRUE}
cb <- make_cubble(
  spatial = stations_sf, temporal = meteo, 
  key = id, index = date)
class(cb)
#cb %>% sf::st_transform(crs = "EPSG:3857")
```


## Comparison to other spatio-temporal classes {#tidyverse}

Some readers may question why a new data structure is needed rather than directly creating a list-column  on the combined data using \code{dplyr::nest_by()}. The reason is that the \code{cubble} object is specifically designed to utilize the spatio-temporal structure when arranging observations in a single object. Moreover, it enables easy pivoting between purely spatial, purely temporal, or unfolded into a combined form.

From the initial \pkg{spacetime} [@spacetime] package. New packages, such as \pkg{stars} [@stars] and \pkg{sftime} [@sftime], have [...]. This section compares and contrast the cubble data structure with other existing alternative, namely \pkg{stars} and \pkg{sftime}.

The `stars` package creates a `stars` object from an array and a dimension object. In many cases, i.e. satellite images, this is convenient, however, there are also many spatio-temporal data are formatted in 2D data frames. 

create a dimension object, populate the data into the array

- array in \proglang{R} allows for character, 
- specific datetime class

*make the example simpler*

  - `temporal$var1 %>% matrix(byrow = TRUE, nrow = 2, ncol = 5)`
  
This happens when different stations have different start date and require other software to reshape the data correctly. 


<!-- The temporal data contains two variables are recorded at two stations (`id`) from 2023 March 21st to 2023 March 25th. Notice is that id2 only records from 2023 March 22nd and variable 2 has an `NA` value on  2023 March 23rd at id2. -->

<!-- ```{r echo = FALSE} -->
<!-- library(stars) -->
<!-- spatial <- tibble( -->
<!--   id = c(1,2), -->
<!--   long = c(130, 140), -->
<!--   lat = c(-38, -44), -->
<!--   name = c("station 1", "station 2"))  -->

<!-- spatial -->

<!-- temporal <- tibble( -->
<!--   id = c(rep(1, each = 5), rep(2, each = 4)), -->
<!--   time = c(seq(as.Date("2023-03-21"), as.Date("2023-03-25"), 1), -->
<!--            seq(as.Date("2023-03-22"), as.Date("2023-03-25"), 1)), -->
<!--   var1 = c(3, 6, 8, 2, 5, 7, 9, 14, 5), -->
<!--   var2 = c(1, 3, 4, 2, 6, 7, NA, 5, 8) -->
<!-- ) -->
<!-- temporal -->
<!-- ``` -->

<!-- The following code can be used to create the dimension object: -->

<!-- ```{r echo = TRUE} -->
<!-- spatial_sf <- spatial %>% sf::st_as_sf(coords = c("long", "lat"), crs = 4326)  -->
<!-- station_vec <- st_geometry(spatial_sf) -->
<!-- time_vec <- unique(temporal$time) -->
<!-- var_vec <- spatial_sf$name -->
<!-- d <- st_dimensions(station = station_vec, time = time_vec) -->
<!-- d -->
<!-- ``` -->

<!-- However, the issue comes when casting the variables into an array of the same dimension: -->

<!-- ```{r echo = TRUE, eval = FALSE} -->
<!-- temporal$var1 %>% matrix(byrow = TRUE, nrow = 2, ncol = 5) %>% array(dim = dim(d)) -->
<!-- ``` -->

<!-- Due to the missingness on 2023 March 21st for id2, the array reuses the first value of the variable to fill in the dimension (the missingness at (2,1) is not flagged and 3 is reused to fill in the dimension). -->

<!-- This causes an issue when multiple stations with different recording periods present in the data, commonly found in the weather data.  -->

The approach taken by the \pkg{sftime} package is to combine the spatial and temporal variables together into a joint table. [for sf objects with daily observation, memory efficiency]

Consider the climate data used in the \pkg{cubble} package, \code{climate_aus}. It contains daily precipitation, minimum and maximum temperature for 639 weather stations across Australia in 2020. The converted sftime object is `r library(cubble); #object.size(sftime::st_as_sftime(climate_aus))/object.size(climate_aus)` times the size of the cubble object:

```{r echo = TRUE}
#climate_aus %>% sftime::st_as_sftime() %>% object.size()
climate_aus %>% object.size()
```


